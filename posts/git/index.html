<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Git Tutorial | Cookie's Blog</title>
<meta name=keywords content="git"><meta name=description content="git的使用"><meta name=author content="Me"><link rel=canonical href=https://canonical.url/to/page><link crossorigin=anonymous href=/assets/css/stylesheet.min.ec8da366ca2fb647537ccb7a8f6fa5b4e9cd3c7a0d3171dd2d3baad1e49c8bfc.css integrity="sha256-7I2jZsovtkdTfMt6j2+ltOnNPHoNMXHdLTuq0eSci/w=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2eadbb982468c11a433a3e291f01326f2ba43f065e256bf792dbd79640a92316.js integrity="sha256-Lq27mCRowRpDOj4pHwEybyukPwZeJWv3ktvXlkCpIxY=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://dueplay.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://dueplay.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://dueplay.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://dueplay.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://dueplay.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://dueplay.github.io/posts/git/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-4XHWHM02GB"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-4XHWHM02GB")}</script><meta property="og:title" content="Git Tutorial"><meta property="og:description" content="git的使用"><meta property="og:type" content="article"><meta property="og:url" content="https://dueplay.github.io/posts/git/"><meta property="og:image" content="https://dueplay.github.io/%3Cimage%20path/url%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-01-20T10:42:01+08:00"><meta property="article:modified_time" content="2022-01-20T10:42:01+08:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://dueplay.github.io/%3Cimage%20path/url%3E"><meta name=twitter:title content="Git Tutorial"><meta name=twitter:description content="git的使用"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://dueplay.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Git Tutorial","item":"https://dueplay.github.io/posts/git/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Git Tutorial","name":"Git Tutorial","description":"git的使用","keywords":["git"],"articleBody":"Git Local 1.Check the Version $ git --version 2.Configure Git 我们通常会将 git 配置为我们在 github 上注册的用户名/电子邮件/密码。global 关键字会为系统中的每个版本库设置配置。我们可以去掉 global 关键字，只对当前仓库进行配置。\n# 配置 $ git config --global user.name \"Dueplay\" $ git config --global user.email \"2289535823@qq.com\" $ git config --global user.password \"your passwd\" # 查看配置 $ git config user.name Dueplay $ git config user.email 2289535823@qq.com $ git config user.password hello123 3. Initialize Git 创建一个新的 repo，并如下初始化 git 以跟踪一个文件夹：\n$ mkdir myproject \u0026\u0026 cd myproject $ git init 在myproject有个隐藏文件夹 .git ，这是 git 为我们存储所有跟踪信息的地方。\n4. Check Status $ git status On branch master No commits yet Untracked files: (use \"git add ...\" to include in what will be committed) index.html nothing added to commit but untracked files present (use \"git add\" to track) 5.暂存新的改变到工作区 在Git中，“暂存”（Staging）指的是将工作目录中的修改或新文件添加到Git的索引中（也称为暂存区），以便随后commit这些更改。暂存的主要目的是允许选择性地commit文件而不是全部文件的修改，通过使用暂存区，可以控制哪些修改被包含在下次commit中。\n在 git 中，每个文件都可能处于两个阶段中的一个：\n已跟踪–git 会主动监控该文件的任何更改，并将其作为 repo 的一部分 未跟踪–虽然文件存在，但 git 会 “忽略 “它的存在和变化\n# $ git add index.html # $ git restore --staged [filename] 6.Commit Changes $ git commit -m \"First release of Git Helloworld Project\" 可以跳过暂存阶段，一步到位地comiit变更。不建议这样做\ngit commit -a -m [commit message] git tag 用于给 Git 中的commit打上标签（tag），这些标签通常用于标识某个特殊的commit，比如软件版本发布。标签提供了一个稳定的引用，使得方便地回溯到某个特定的commit，常用的命令选项有\n• -a：用于创建一个带注释的标签 • -m：指定标签的注释信息 • -l：列出已有的标签 7. Commit History $ git log # 精简log $ git log --oneline 8.Help git有这么多的标志选项和命令\ngit help –all 会显示所有可用的 git 命令。\ngit [command] -help 会显示该命令可设置的所有标志，而 git [command] –help 则会打开该命令的手册。(单–和双–）\n9.Git Branch 创建新分支\n$ git branch hello-world-image 查看这个仓库所有可用的分支\n$ git branch hello-world-image * master 如果我们切换master主分支，新快照就不是主分支的一部分。我们在另一个分支中的新更改不会影响主分支。\n通过 checkout 命令从主分支转移到新创建的分支：\n$ git checkout hello-world-image Switched to branch 'hello-world-image' 创建和切换到新分支可一步完成\n$ git checkout -b hello-world-image 删除分支\ngit branch -d 如果分支有未合并的更改，Git会拒绝删除，并提醒先合并或解决冲突。当然也可以强制删除分支，包括未合并的修改。\ngit branch -D 注意，无法删除主分支、当前所在分支或非分支的内容\n10.Merge Branch git merge 是 Git 中用于合并不同分支的命令。将两个或多个分支的历史和更改集成到一个新的commit中的过程。合并操作通常用于将一个分支的变更合并到另一个分支，以确保这两个分支包含了相同的代码更改。假设我们对 hello-world-image 分支中的新开发非常满意，决定将其合并回主分支。注意master上是没有新提交的。\n既然要合并到主分支，我们首先要确保自己是站在主分支上的：\n$ git checkout master Switched to branch 'master' # 使用merge合并分支，将指定分支中的更改合并到当前分支master $ git merge hello-world-image Updating 2daa287..c31a2c0 Fast-forward img_hello_world.png | Bin 0 -\u003e 48630 bytes 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 img_hello_world.png 我们看到 git 说这次合并是 “Fast-forward”，因为它没有发现这两个分支有任何冲突，合并进行得很顺利。\n然而，生活并不总是一帆风顺。有时会发生合并冲突。\n假设现在我们回到 hello-world-image，在 index.html 中添加一行新内容。同时，我们在主分支中删除 index.html 中的一行，并在两个分支中都提交更改。\n现在，当我们尝试将此提交与主分支合并时，这种叫做Three-way Merge，冲突就会发生：\n$ git merge hello-world-image Auto-merging index.html CONFLICT (content): Merge conflict in index.html Automatic merge failed; fix conflicts and then commit the result. 我们可以打开 index.html，看看 git 对冲突发生的原因和方式做了哪些标记：\n\u003c!DOCTYPE html\u003e Hello World! ","wordCount":"1579","inLanguage":"en","image":"https://dueplay.github.io/%3Cimage%20path/url%3E","datePublished":"2022-01-20T10:42:01+08:00","dateModified":"2022-01-20T10:42:01+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://dueplay.github.io/posts/git/"},"publisher":{"@type":"Organization","name":"Cookie's Blog","logo":{"@type":"ImageObject","url":"https://dueplay.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://dueplay.github.io/ accesskey=h title="Home (Alt + H)">Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></span></div><ul id=menu><li><a href=https://dueplay.github.io/archives/ title=⏱archives><span>⏱archives</span></a></li><li><a href=https://dueplay.github.io/search/ title=🔍Search><span>🔍Search</span></a></li><li><a href=https://dueplay.github.io/tags/ title=🔖Tags><span>🔖Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://dueplay.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://dueplay.github.io/posts/>Posts</a></div><h1 class=post-title>Git Tutorial</h1><div class=post-description>git的使用</div><div class=post-meta>&lt;span title='2022-01-20 10:42:01 +0800 +0800'>2022-01-20&lt;/span>&amp;nbsp;·&amp;nbsp;8 min&amp;nbsp;·&amp;nbsp;1579 words&amp;nbsp;·&amp;nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/Dueplay/blog/content/posts/git.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><ul><li><a href=#git-local>Git Local</a></li><li><a href=#2git-remote>2.Git Remote</a></li><li><a href=#1与远程仓库同步>1.与远程仓库同步</a></li><li><a href=#2拉取远程仓库新东西到本地>2.拉取远程仓库新东西到本地</a></li><li><a href=#3推送本地新修改到远程>3.推送本地新修改到远程</a></li><li><a href=#4remote-branch-pull>4.Remote Branch Pull</a></li><li><a href=#5将本地分支推送到远程>5.将本地分支推送到远程</a></li><li><a href=#6merge-into-master>6.Merge Into Master</a></li><li><a href=#7clone-and-fork>7.clone and fork</a></li><li><a href=#8git-ignore>8.Git Ignore</a></li><li><a href=#8remove-origin>8.remove origin</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h3 id=git-local>Git Local<a hidden class=anchor aria-hidden=true href=#git-local>#</a></h3><h4 id=1check-the-version>1.Check the Version<a hidden class=anchor aria-hidden=true href=#1check-the-version>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git --version
</span></span></code></pre></div><h4 id=2configure-git>2.Configure Git<a hidden class=anchor aria-hidden=true href=#2configure-git>#</a></h4><p>我们通常会将 git 配置为我们在 github 上注册的用户名/电子邮件/密码。<strong>global</strong> 关键字会为系统中的每个版本库设置配置。我们可以去掉 <strong>global</strong> 关键字，只对当前仓库进行配置。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 配置</span>
</span></span><span class=line><span class=cl>$ git config --global user.name <span class=s2>&#34;Dueplay&#34;</span>
</span></span><span class=line><span class=cl>$ git config --global user.email <span class=s2>&#34;2289535823@qq.com&#34;</span>
</span></span><span class=line><span class=cl>$ git config --global user.password <span class=s2>&#34;your passwd&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 查看配置</span>
</span></span><span class=line><span class=cl>$ git config user.name
</span></span><span class=line><span class=cl>Dueplay
</span></span><span class=line><span class=cl>$ git config user.email
</span></span><span class=line><span class=cl>2289535823@qq.com
</span></span><span class=line><span class=cl>$ git config user.password
</span></span><span class=line><span class=cl>hello123
</span></span></code></pre></div><h4 id=3-initialize-git>3. Initialize Git<a hidden class=anchor aria-hidden=true href=#3-initialize-git>#</a></h4><p>创建一个新的 repo，并如下初始化 git 以跟踪一个文件夹：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ mkdir myproject <span class=o>&amp;&amp;</span> <span class=nb>cd</span> myproject
</span></span><span class=line><span class=cl>$ git init
</span></span></code></pre></div><p>在myproject有个隐藏文件夹 .git ，这是 git 为我们存储所有跟踪信息的地方。</p><h4 id=4-check-status>4. Check Status<a hidden class=anchor aria-hidden=true href=#4-check-status>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git status
</span></span><span class=line><span class=cl>On branch master
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>No commits yet
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Untracked files:
</span></span><span class=line><span class=cl>  <span class=o>(</span>use <span class=s2>&#34;git add &lt;file&gt;...&#34;</span> to include in what will be committed<span class=o>)</span>
</span></span><span class=line><span class=cl>	index.html
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>nothing added to commit but untracked files present <span class=o>(</span>use <span class=s2>&#34;git add&#34;</span> to track<span class=o>)</span>
</span></span></code></pre></div><h4 id=5暂存新的改变到工作区>5.暂存新的改变到工作区<a hidden class=anchor aria-hidden=true href=#5暂存新的改变到工作区>#</a></h4><p>在Git中，&ldquo;暂存&rdquo;（Staging）指的是将<strong>工作目录中的修改或新文件添加到Git的索引中（也称为暂存区），以便随后commit这些更改</strong>。暂存的主要目的是允许选择性地commit文件而不是全部文件的修改，通过使用暂存区，可以控制哪些修改被包含在下次commit中。</p><p>在 git 中，每个文件都可能处于两个阶段中的一个：</p><p>已跟踪&ndash;git 会主动监控该文件的任何更改，并将其作为 repo 的一部分
未跟踪&ndash;虽然文件存在，但 git 会 &ldquo;忽略 &ldquo;它的存在和变化</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># </span>
</span></span><span class=line><span class=cl>$ git add index.html
</span></span><span class=line><span class=cl><span class=c1># </span>
</span></span><span class=line><span class=cl>$ git restore --staged <span class=o>[</span>filename<span class=o>]</span>
</span></span></code></pre></div><h4 id=6commit-changes>6.Commit Changes<a hidden class=anchor aria-hidden=true href=#6commit-changes>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git commit -m <span class=s2>&#34;First release of Git Helloworld Project&#34;</span>
</span></span></code></pre></div><p>可以跳过暂存阶段，一步到位地comiit变更。不建议这样做</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git commit -a -m <span class=o>[</span>commit message<span class=o>]</span>
</span></span></code></pre></div><p><code>git tag</code> 用于给 Git 中的commit打上标签（tag），这些标签通常用于标识某个特殊的commit，比如软件版本发布。标签提供了一个稳定的引用，使得方便地回溯到某个特定的commit，常用的命令选项有</p><ul><li>• <code>-a</code>：用于创建一个带注释的标签</li><li>• <code>-m</code>：指定标签的注释信息</li><li>• <code>-l</code>：列出已有的标签</li></ul><h4 id=7-commit-history>7. Commit History<a hidden class=anchor aria-hidden=true href=#7-commit-history>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git log
</span></span><span class=line><span class=cl><span class=c1># 精简log</span>
</span></span><span class=line><span class=cl>$ git log --oneline
</span></span></code></pre></div><h4 id=8help>8.Help<a hidden class=anchor aria-hidden=true href=#8help>#</a></h4><p>git有这么多的标志选项和命令</p><p>git help &ndash;all 会显示所有可用的 git 命令。</p><p>git [command] -help 会显示该命令可设置的所有标志，而 git [command] &ndash;help 则会打开该命令的手册。(单&ndash;和双&ndash;）</p><h4 id=9git-branch>9.Git Branch<a hidden class=anchor aria-hidden=true href=#9git-branch>#</a></h4><p>创建新分支</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git branch hello-world-image
</span></span></code></pre></div><p>查看这个仓库所有可用的分支</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git branch
</span></span><span class=line><span class=cl>  hello-world-image
</span></span><span class=line><span class=cl>* master
</span></span></code></pre></div><p>如果我们切换master主分支，新快照就不是主分支的一部分。我们在另一个分支中的新更改不会影响主分支。</p><p>通过 checkout 命令从主分支转移到新创建的分支：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git checkout hello-world-image
</span></span><span class=line><span class=cl>Switched to branch <span class=s1>&#39;hello-world-image&#39;</span>
</span></span></code></pre></div><p>创建和切换到新分支可一步完成</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git checkout -b hello-world-image
</span></span></code></pre></div><p>删除分支</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git branch -d &lt;branch-name&gt;
</span></span></code></pre></div><p>如果分支有未合并的更改，Git会拒绝删除，并提醒先合并或解决冲突。当然也可以强制删除分支，包括未合并的修改。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git branch -D &lt;branch-name&gt;
</span></span></code></pre></div><p>注意，无法删除主分支、当前所在分支或非分支的内容</p><h4 id=10merge-branch>10.Merge Branch<a hidden class=anchor aria-hidden=true href=#10merge-branch>#</a></h4><p><code>git merge</code> 是 Git 中用于合并不同分支的命令。<strong>将两个或多个分支的历史和更改集成到一个新的commit中的过程</strong>。合并操作通常用于将一个分支的变更合并到另一个分支，以确保这两个分支包含了相同的代码更改。假设我们对 hello-world-image 分支中的新开发非常满意，决定将其合并回主分支。注意master上是没有新提交的。</p><p>既然要合并到主分支，我们首先要确保自己是站在主分支上的：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git checkout master
</span></span><span class=line><span class=cl>Switched to branch <span class=s1>&#39;master&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 使用merge合并分支，将指定分支中的更改合并到当前分支master</span>
</span></span><span class=line><span class=cl>$ git merge hello-world-image
</span></span><span class=line><span class=cl>Updating 2daa287..c31a2c0
</span></span><span class=line><span class=cl>Fast-forward
</span></span><span class=line><span class=cl> img_hello_world.png <span class=p>|</span> Bin <span class=m>0</span> -&gt; <span class=m>48630</span> bytes
</span></span><span class=line><span class=cl> <span class=m>1</span> file changed, <span class=m>0</span> insertions<span class=o>(</span>+<span class=o>)</span>, <span class=m>0</span> deletions<span class=o>(</span>-<span class=o>)</span>
</span></span><span class=line><span class=cl> create mode <span class=m>100644</span> img_hello_world.png
</span></span></code></pre></div><p>我们看到 git 说这次合并是 &ldquo;Fast-forward&rdquo;，因为它没有发现这两个分支有任何冲突，合并进行得很顺利。</p><p>然而，生活并不总是一帆风顺。有时会发生合并冲突。</p><p>假设现在我们回到 hello-world-image，在 index.html 中添加一行新内容。同时，我们在主分支中删除 index.html 中的一行，并在两个分支中都<strong>提交更改</strong>。</p><p>现在，当我们尝试将此提交与主分支合并时，这种叫做Three-way Merge，冲突就会发生：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git merge hello-world-image
</span></span><span class=line><span class=cl>Auto-merging index.html
</span></span><span class=line><span class=cl>CONFLICT <span class=o>(</span>content<span class=o>)</span>: Merge conflict in index.html
</span></span><span class=line><span class=cl>Automatic merge failed<span class=p>;</span> fix conflicts and <span class=k>then</span> commit the result.
</span></span></code></pre></div><p>我们可以打开 index.html，看看 git 对冲突发生的原因和方式做了哪些标记：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>&lt;!DOCTYPE html&gt;
</span></span><span class=line><span class=cl>&lt;html&gt;
</span></span><span class=line><span class=cl>&lt;head&gt;
</span></span><span class=line><span class=cl>&lt;title&gt;Hello World!&lt;/title&gt;
</span></span><span class=line><span class=cl>&lt;link <span class=nv>rel</span><span class=o>=</span><span class=s2>&#34;stylesheet&#34;</span> <span class=nv>href</span><span class=o>=</span><span class=s2>&#34;bluestyle.css&#34;</span>&gt;
</span></span><span class=line><span class=cl>&lt;/head&gt;
</span></span><span class=line><span class=cl>&lt;body&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>&lt;h1&gt;Hello world!&lt;/h1&gt;
</span></span><span class=line><span class=cl>&lt;p&gt;This is the first file in my new Git Repo.&lt;/p&gt;
</span></span><span class=line><span class=cl><span class=o>&lt;&lt;&lt;&lt;&lt;&lt;</span>&lt; <span class=nv>HEAD</span>
</span></span><span class=line><span class=cl><span class=o>=======</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>&lt;p&gt;A old line in our file!&lt;/p&gt;
</span></span><span class=line><span class=cl>&gt;&gt;&gt;&gt;&gt;&gt;&gt; hello-world-image
</span></span><span class=line><span class=cl>&lt;/body&gt;
</span></span><span class=line><span class=cl>&lt;/html&gt;
</span></span></code></pre></div><p>我们可以选择保留 &#171;&#171;&#171;&lt; HEAD 至 ======= 之间的所有内容，或者保留 ======= 至 &#187;&#187;&#187;> hello-world-image 之间的所有内容。</p><p>在对 index.html 中的冲突部分做出选择后，我们将文件暂存并提交，以结束这次合并操作。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git add index.html
</span></span><span class=line><span class=cl>$ git commit -m <span class=s2>&#34;after fix the conflict&#34;</span>
</span></span><span class=line><span class=cl><span class=o>[</span>master bdfc2b1<span class=o>]</span> after fix the conflict
</span></span></code></pre></div><p>这样就完成了两个冲突分支的合并，通过 -d 标志，我们可以删除合并后的分支，以保持工作区的整洁：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git branch -d hello-world-images
</span></span><span class=line><span class=cl>Deleted branch hello-world-image <span class=o>(</span>was 9e7a8ee<span class=o>)</span>.
</span></span></code></pre></div><p><code>--no-ff</code> 选项用于强制创建一个新的合并commit，即使可以执行快速前进合并，这样可以保留每个分支的独立历史</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl> git merge --no-ff &lt;branch-name&gt;
</span></span></code></pre></div><p>要执行Fast-forward 合并：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git merge --ff &lt;branch-name&gt;
</span></span></code></pre></div><h4 id=11revert>11.Revert<a hidden class=anchor aria-hidden=true href=#11revert>#</a></h4><p>revert 命令用于删除之前的提交，并将删除内容变成新的提交，而不修改日志。</p><p>首先，我们要检查哪个提交是我们想要返回的：（使用 &ndash;oneline 关键字显示简洁的 git 日志）</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git log --oneline
</span></span><span class=line><span class=cl>bdfc2b1 <span class=o>(</span>HEAD -&gt; master<span class=o>)</span> fix conflicts:
</span></span><span class=line><span class=cl>9e7a8ee add a line
</span></span><span class=line><span class=cl>17fd1f5 remove a line
</span></span><span class=line><span class=cl>5ec2abb a small change
</span></span><span class=line><span class=cl>c31a2c0 Added image to Hello World
</span></span><span class=line><span class=cl>2daa287 Another changes
</span></span><span class=line><span class=cl>48d7a59 First release of Git Helloworld Project
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ git revert 9e7a8ee --no-edit
</span></span></code></pre></div><h4 id=12reset>12.Reset<a hidden class=anchor aria-hidden=true href=#12reset>#</a></h4><p>用于将分支的 HEAD 指针和工作目录重置到指定的commit，可以选择是否保留未commit的更改，reset 会将 repo 全部移回之前的提交，会删除该提交和最新版本之间的所有更改。</p><p>现在，假设我们添加了两个文件 file1.txt、file2.txt 和 file3.txt，并将它们包含在两个不同的提交中：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ touch file1.txt file2.txt file3.txt
</span></span><span class=line><span class=cl>$ git add file1.txt <span class=o>&amp;&amp;</span> git commit -m <span class=s2>&#34;Add file1&#34;</span>
</span></span><span class=line><span class=cl>$ git add file2.txt <span class=o>&amp;&amp;</span> git commit -m <span class=s2>&#34;Add file2&#34;</span>
</span></span><span class=line><span class=cl>$ git add file3.txt <span class=o>&amp;&amp;</span> git commit -m <span class=s2>&#34;Add file3&#34;</span>
</span></span><span class=line><span class=cl>$ git log --oneline
</span></span><span class=line><span class=cl>327ae72 <span class=o>(</span>HEAD -&gt; master<span class=o>)</span> Add file3
</span></span><span class=line><span class=cl>8b159b4 Add file2
</span></span><span class=line><span class=cl>cf9f3bf Add file1
</span></span><span class=line><span class=cl>...<span class=o>(</span>more<span class=o>)</span>...
</span></span></code></pre></div><p>现在我们不需要文件 2 和文件 3，但希望保留文件 1。我们可以分别revert最近的 2 次提交，或者reset回添加 file1 的提交。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git reset cf9f3bf
</span></span><span class=line><span class=cl>$ git log
</span></span><span class=line><span class=cl>cf9f3bf <span class=o>(</span>HEAD -&gt; master<span class=o>)</span> Add file1
</span></span><span class=line><span class=cl>...<span class=o>(</span>more<span class=o>)</span>...
</span></span></code></pre></div><p>警告：通常情况下，乱动版本库的提交历史是很危险的，尤其是在与他人合作时。</p><p>如果我们知道 git 的提交哈希值，就有办法撤销reset。在前面的例子中，即使我们reset回 file1 的提交，我们仍然可以返回，因为我们知道上次添加文件 3 的提交哈希值是 327ae72。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git reset 327ae72
</span></span><span class=line><span class=cl>$ git log
</span></span><span class=line><span class=cl>327ae72 <span class=o>(</span>HEAD -&gt; master<span class=o>)</span> Add file3
</span></span><span class=line><span class=cl>8b159b4 Add file2
</span></span><span class=line><span class=cl>cf9f3bf Add file1
</span></span><span class=line><span class=cl>...<span class=o>(</span>more<span class=o>)</span>...
</span></span></code></pre></div><p>reset其实有三个主要的选项：<code>--soft</code>、<code>--mixed</code> 和 <code>--hard</code>，对应于不同的重置模式</p><p>git reset &ndash;soft ：回退 HEAD 指针到指定的commit，但保留所有的更改。<strong>即不会修改工作目录或暂存区</strong>，所有的更改都被标记为未commit的更改，可以直接重新commit</p><p>git reset &ndash;mixed ：<strong>默认的reset模式</strong>。回退 HEAD 指针到指定的commit，<strong>并且重置暂存区</strong>，<strong>但保留工作目录中的更改</strong>。<strong>即未commit的更改会保留在工作目录，但不会被标记为暂存区的更改，需要重新<code>add</code>并commit</strong></p><p>git reset &ndash;hard ：<strong>最彻底的reset模式</strong>。回退 HEAD 指针到指定的commit，<strong>重置暂存区，并删除工作目录中未commit的更改</strong>，<strong>慎用这个玩意，因为它会永久性地删除未commit的更改</strong></p><h4 id=13amend>13.Amend<a hidden class=anchor aria-hidden=true href=#13amend>#</a></h4><p>commit &ndash;amend 可用于修改最近的提交，并交换更改其提交信息。</p><p>它将暂存区域的改动与最新提交结合起来，并从中创建一个新提交，取代最新提交。</p><p>例如，我们对 README.md 稍作改动，想要提交，但在提交信息中输入了不少错别字。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git add README.md
</span></span><span class=line><span class=cl>$ git commit -m <span class=s2>&#34;Upated: RMEADE.md (ugly typos)&#34;</span>
</span></span><span class=line><span class=cl>$ git log --oneline
</span></span><span class=line><span class=cl>b0dfb07 <span class=o>(</span>HEAD -&gt; master<span class=o>)</span> Upated: RMEADE.md <span class=o>(</span>ugly typos<span class=o>)</span>
</span></span><span class=line><span class=cl>327ae72 Add file3
</span></span><span class=line><span class=cl>...<span class=o>(</span>more<span class=o>)</span>...
</span></span></code></pre></div><p>我们的错别字让 git 历史看起来很糟糕。使用amend修改提交语句</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git commit --amend -m <span class=s2>&#34;Update: README.md (beautiful)&#34;</span>
</span></span><span class=line><span class=cl>$ git log --oneline
</span></span><span class=line><span class=cl>d4bf700 <span class=o>(</span>HEAD -&gt; master<span class=o>)</span> Update: README.md <span class=o>(</span>beautiful<span class=o>)</span>
</span></span><span class=line><span class=cl>327ae72 Add file3
</span></span><span class=line><span class=cl>...<span class=o>(</span>more<span class=o>)</span>...
</span></span></code></pre></div><h4 id=14stash>14.stash<a hidden class=anchor aria-hidden=true href=#14stash>#</a></h4><p><code>git stash</code> <strong>是一个用于保存当前工作目录和暂存区的临时状态的命令</strong>。允许在切换分支、应用补丁或执行其他操作之前，将当前的修改存储起来，以便稍后重新应用，非常非常实用，常见的使用场景如</p><ul><li>\1. 保存当前工作目录和暂存区的状态</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git stash save <span class=s2>&#34;Work in progress&#34;</span>
</span></span></code></pre></div><ul><li>\2. 切换到其他分支进行操作</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git checkout other-branch
</span></span></code></pre></div><ul><li>\3. 在其他分支进行操作</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 在 other-branch 上进行一些操作</span>
</span></span></code></pre></div><ul><li>\4. 切回原始分支并恢复 <code>stash</code></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git checkout original-branch
</span></span><span class=line><span class=cl>git stash apply
</span></span></code></pre></div><p>或者，如果想同时删除 <code>stash</code>，可以使用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git stash pop
</span></span></code></pre></div><p>此外，还有一些其他常用命令</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git stash list <span class=c1># 显示 Git 存储库中所有存储的列表，以及有关每个存储的一些信息</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>git stash branch &lt;branch-name&gt; <span class=c1># 将更改应用到不同的分支</span>
</span></span></code></pre></div><h3 id=2git-remote>2.Git Remote<a hidden class=anchor aria-hidden=true href=#2git-remote>#</a></h3><p>首先需要创建一个新的 github 仓库，然后上传我们目前正在开发的本地仓库，以便同步。</p><p>为了方便起见，我们将远程仓库也命名为 myproject。</p><h3 id=1与远程仓库同步>1.与远程仓库同步<a hidden class=anchor aria-hidden=true href=#1与远程仓库同步>#</a></h3><p>在本地项目仓库中，我们需要添加一个远程跟踪链接：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git remote add origin https://github.com/Dueplay/myproject.git
</span></span></code></pre></div><p>通过 git remote -v 检查是否与 github 上的 repo 远程同步</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git remote -v
</span></span><span class=line><span class=cl>origin	https://github.com/<span class=o>[</span>username<span class=o>]</span>/myproject.git <span class=o>(</span>fetch<span class=o>)</span>
</span></span><span class=line><span class=cl>origin	https://github.com/<span class=o>[</span>username<span class=o>]</span>/myproject.git <span class=o>(</span>push<span class=o>)</span>
</span></span></code></pre></div><p>然后，我们就可以将所有本地开发的内容推送到远程版本库：</p><p><strong>git push</strong>：将本地更改推送到远程仓库的命令，完整格式 ：git push</p><ul><li><code>&lt;remote></code> 是远程仓库的名称，通常是 &ldquo;origin&rdquo; 或其他你设置的别名。</li><li><code>&lt;branch></code> 是本地分支的名称，它将被推送到远程仓库的同名分支。</li></ul><p><strong>&ndash;set-upstream</strong>（或者简写为 -u）: 这部分告诉Git为本地分支与远程分支建立关联关系。关联关系的作用是在将来的推送或拉取操作中，Git会自动识别要使用的远程分支。设置关联关系后，你就可以使用<code>git push</code>和<code>git pull</code>而不需要每次都指定远程仓库和分支,只需输入 <code>git push</code>，Git 将自动使用关联的远程和分支。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git push --set-upstream origin master
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>Enumerating objects: 34, <span class=k>done</span>.
</span></span><span class=line><span class=cl>Counting objects: 100% <span class=o>(</span>34/34<span class=o>)</span>, <span class=k>done</span>.
</span></span><span class=line><span class=cl>Delta compression using up to <span class=m>8</span> threads
</span></span><span class=line><span class=cl>Compressing objects: 100% <span class=o>(</span>33/33<span class=o>)</span>, <span class=k>done</span>.
</span></span><span class=line><span class=cl>Writing objects: 100% <span class=o>(</span>34/34<span class=o>)</span>, 49.37 KiB <span class=p>|</span> 12.34 MiB/s, <span class=k>done</span>.
</span></span><span class=line><span class=cl>Total <span class=m>34</span> <span class=o>(</span>delta 17<span class=o>)</span>, reused <span class=m>0</span> <span class=o>(</span>delta 0<span class=o>)</span>, pack-reused <span class=m>0</span>
</span></span><span class=line><span class=cl>remote: Resolving deltas: 100% <span class=o>(</span>17/17<span class=o>)</span>, <span class=k>done</span>.
</span></span><span class=line><span class=cl>To https://github.com/<span class=o>[</span>username<span class=o>]</span>/myproject.git
</span></span><span class=line><span class=cl> * <span class=o>[</span>new branch<span class=o>]</span>      master -&gt; master
</span></span><span class=line><span class=cl>Branch <span class=s1>&#39;master&#39;</span> <span class=nb>set</span> up to track remote branch <span class=s1>&#39;master&#39;</span> from <span class=s1>&#39;origin&#39;</span>.
</span></span><span class=line><span class=cl>/*你的本地 master 分支现在已设置为跟踪远程仓库 <span class=s1>&#39;origin&#39;</span> 上的远程 master 分支*/
</span></span></code></pre></div><p>现在，我们已将本地所有开发成果上传到远程版本库</p><h3 id=2拉取远程仓库新东西到本地>2.拉取远程仓库新东西到本地<a hidden class=anchor aria-hidden=true href=#2拉取远程仓库新东西到本地>#</a></h3><p>现在，假设远程 repo 上出现了新情况。在此，我们将模拟这种情况，直接从 github 上的 README.md 中移除一行并提交。</p><p>我们如何更新本地版本库以包含这些更改呢？</p><p>我们有两个选择：</p><ul><li><code>fetch</code> + <code>merge</code></li><li><code>pull</code></li></ul><p>从第一个组合开始。我们首先需要使用 fetch 从远程下载所有新更改</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git fetch origin
</span></span><span class=line><span class=cl>remote: Enumerating objects: 5, <span class=k>done</span>.
</span></span><span class=line><span class=cl>remote: Counting objects: 100% <span class=o>(</span>5/5<span class=o>)</span>, <span class=k>done</span>.
</span></span><span class=line><span class=cl>remote: Compressing objects: 100% <span class=o>(</span>1/1<span class=o>)</span>, <span class=k>done</span>.
</span></span><span class=line><span class=cl>remote: Total <span class=m>3</span> <span class=o>(</span>delta 2<span class=o>)</span>, reused <span class=m>2</span> <span class=o>(</span>delta 2<span class=o>)</span>, pack-reused <span class=m>0</span>
</span></span><span class=line><span class=cl>Unpacking objects: 100% <span class=o>(</span>3/3<span class=o>)</span>, <span class=m>689</span> bytes <span class=p>|</span> 344.00 KiB/s, <span class=k>done</span>.
</span></span><span class=line><span class=cl>From https://github.com/<span class=o>[</span>username<span class=o>]</span>/myproject
</span></span><span class=line><span class=cl>   d4bf700..6d4ad42  master     -&gt; origin/master
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl><span class=c1># 现在我们有了来自远程的新改动，可以检查一下 git 状态了：</span>
</span></span><span class=line><span class=cl>$ git status
</span></span><span class=line><span class=cl>On branch master
</span></span><span class=line><span class=cl>Your branch is behind <span class=s1>&#39;origin/master&#39;</span> by <span class=m>1</span> commit, and can be fast-forwarded.
</span></span><span class=line><span class=cl>  <span class=o>(</span>use <span class=s2>&#34;git pull&#34;</span> to update your <span class=nb>local</span> branch<span class=o>)</span>
</span></span></code></pre></div><p>我们看到本地仓库比上游主仓库晚提交了 1 次，即 README.md 上的一行改动。我们可以使用 git diff 命令仔细检查具体的差异</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git diff origin/master
</span></span><span class=line><span class=cl>diff --git a/README.md b/README.md
</span></span><span class=line><span class=cl>index f3fa9a9..cf28200 <span class=m>100644</span>
</span></span><span class=line><span class=cl>--- a/README.md
</span></span><span class=line><span class=cl>+++ b/README.md
</span></span><span class=line><span class=cl>@@ -3,3 +3,5 @@ Hello World repository <span class=k>for</span> Git tutorial
</span></span><span class=line><span class=cl> This is an example repository <span class=k>for</span> the Git tutoial on https://www.w3schools.com
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> This repository is built step by step in the tutorial.
</span></span><span class=line><span class=cl>+
</span></span><span class=line><span class=cl>+a new line
</span></span></code></pre></div><p>合并提交</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git merge origin/master
</span></span><span class=line><span class=cl>Updating d4bf700..6d4ad42
</span></span><span class=line><span class=cl>Fast-forward
</span></span><span class=line><span class=cl> README.md <span class=p>|</span> <span class=m>2</span> --
</span></span><span class=line><span class=cl> <span class=m>1</span> file changed, <span class=m>2</span> deletions<span class=o>(</span>-<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ git status
</span></span><span class=line><span class=cl>On branch master
</span></span><span class=line><span class=cl>Your branch is up to date with <span class=s1>&#39;origin/master&#39;</span>.
</span></span></code></pre></div><p>现在我们的本地 git 已经是最新的了。</p><p>上述方法可行，但有点繁琐。其实我们可以用 pull 命令一步完成更新，它是 fetch 和 merge 的结合。</p><p>让我们把从远程 github 上的 README.md 中删除的新行添加回去，并尝试把更改拉入本地 git。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git pull origin
</span></span><span class=line><span class=cl>remote: Enumerating objects: 5, <span class=k>done</span>.
</span></span><span class=line><span class=cl>remote: Counting objects: 100% <span class=o>(</span>5/5<span class=o>)</span>, <span class=k>done</span>.
</span></span><span class=line><span class=cl>remote: Compressing objects: 100% <span class=o>(</span>3/3<span class=o>)</span>, <span class=k>done</span>.
</span></span><span class=line><span class=cl>remote: Total <span class=m>3</span> <span class=o>(</span>delta 2<span class=o>)</span>, reused <span class=m>0</span> <span class=o>(</span>delta 0<span class=o>)</span>, pack-reused <span class=m>0</span>
</span></span><span class=line><span class=cl>Unpacking objects: 100% <span class=o>(</span>3/3<span class=o>)</span>, <span class=m>696</span> bytes <span class=p>|</span> 232.00 KiB/s, <span class=k>done</span>.
</span></span><span class=line><span class=cl>From https://github.com/<span class=o>[</span>username<span class=o>]</span>/myproject
</span></span><span class=line><span class=cl>   6d4ad42..b2bb9ae  master     -&gt; origin/master
</span></span><span class=line><span class=cl>Updating 6d4ad42..b2bb9ae
</span></span><span class=line><span class=cl>Fast-forward
</span></span><span class=line><span class=cl> README.md <span class=p>|</span> <span class=m>2</span> ++
</span></span><span class=line><span class=cl> <span class=m>1</span> file changed, <span class=m>2</span> insertions<span class=o>(</span>+<span class=o>)</span>
</span></span></code></pre></div><p>可以看到我们已经更新了远程主分支：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git log --oneline
</span></span><span class=line><span class=cl>b2bb9ae <span class=o>(</span>HEAD -&gt; master, origin/master<span class=o>)</span> Add back a new line from github directly
</span></span><span class=line><span class=cl>6d4ad42 Remove the new line README.md  GitHub directly
</span></span><span class=line><span class=cl>d4bf700 Update: README.md <span class=o>(</span>beautiful<span class=o>)</span>
</span></span><span class=line><span class=cl>327ae72 Add file3
</span></span><span class=line><span class=cl>8b159b4 Add file2
</span></span><span class=line><span class=cl>cf9f3bf Add file1
</span></span><span class=line><span class=cl>...<span class=o>(</span>more<span class=o>)</span>...
</span></span></code></pre></div><p><code>git pull</code> 和 <code>git fetch</code> 都是用于从远程仓库获取更新的 Git 命令，但区别为</p><pre tabindex=0><code>git fetch origin
</code></pre><ul><li>• 从远程仓库获取更新的信息，<strong>但并不自动合并或更新本地工作目录， 只是把远程分支的引用和相关对象（commit、tree等）下载到本地，需要手动合并或者在需要的时候将远程分支的变更整合到本地分支上</strong></li></ul><pre tabindex=0><code>git pull origin master
</code></pre><ul><li>• 从远程仓库获取更新的信息，<strong>并尝试将本地工作目录自动合并到获取的更新中</strong></li><li>• <code>git pull</code> 实际上包含了 <code>git fetch</code>，比如在执行 <code>git fetch</code> 之后，立即执行 <code>git merge</code> 也可以将远程分支的更改合并到当前本地分支</li></ul><h3 id=3推送本地新修改到远程>3.推送本地新修改到远程<a hidden class=anchor aria-hidden=true href=#3推送本地新修改到远程>#</a></h3><p>现在，我们将通过 push 命令为远程仓库做出贡献。</p><p>让我们在 README.md 中再添加一行，然后尝试更新远程版本库。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git commit -a -m <span class=s2>&#34;Update readme locally and try push&#34;</span>
</span></span><span class=line><span class=cl><span class=o>[</span>master f8986b8<span class=o>]</span> Update readme locally and try push
</span></span><span class=line><span class=cl> <span class=m>1</span> file changed, <span class=m>1</span> insertion<span class=o>(</span>+<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ git status
</span></span><span class=line><span class=cl>On branch master
</span></span><span class=line><span class=cl>Your branch is ahead of <span class=s1>&#39;origin/master&#39;</span> by <span class=m>1</span> commit.
</span></span><span class=line><span class=cl>  <span class=o>(</span>use <span class=s2>&#34;git push&#34;</span> to publish your <span class=nb>local</span> commits<span class=o>)</span>
</span></span></code></pre></div><p>Git 显示我们比远程主分支早提交 1 次。让我们把更改推送到远程仓库。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git push origin
</span></span></code></pre></div><h3 id=4remote-branch-pull>4.Remote Branch Pull<a hidden class=anchor aria-hidden=true href=#4remote-branch-pull>#</a></h3><p>可以通过github图形用户界面直接在远程仓库创建一个新分支。我们从主分支创建了一个名为 secondary 的新分支，并对 README.md 做了一些修改，直接在 github 上提交。</p><p>我们可以将新分支拉到本地 git 并检查它：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git pull
</span></span><span class=line><span class=cl>remote: Enumerating objects: 5, <span class=k>done</span>.
</span></span><span class=line><span class=cl>remote: Counting objects: 100% <span class=o>(</span>5/5<span class=o>)</span>, <span class=k>done</span>.
</span></span><span class=line><span class=cl>remote: Compressing objects: 100% <span class=o>(</span>3/3<span class=o>)</span>, <span class=k>done</span>.
</span></span><span class=line><span class=cl>remote: Total <span class=m>3</span> <span class=o>(</span>delta 2<span class=o>)</span>, reused <span class=m>0</span> <span class=o>(</span>delta 0<span class=o>)</span>, pack-reused <span class=m>0</span>
</span></span><span class=line><span class=cl>Unpacking objects: 100% <span class=o>(</span>3/3<span class=o>)</span>, <span class=m>697</span> bytes <span class=p>|</span> 232.00 KiB/s, <span class=k>done</span>.
</span></span><span class=line><span class=cl>From https://github.com/<span class=o>[</span>username<span class=o>]</span>/myproject
</span></span><span class=line><span class=cl> * <span class=o>[</span>new branch<span class=o>]</span>      secondary  -&gt; origin/secondary
</span></span><span class=line><span class=cl>Already up to date.
</span></span></code></pre></div><p>我们可以像往常一样通过 git 分支查看新分支。但默认情况下，它只显示本地分支。我们需要使用 -a 标志来查看所有本地和远程分支，或者使用 -r 标志来查看远程分支。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git branch // only <span class=nb>local</span> branches
</span></span><span class=line><span class=cl>* master
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ git branch -a
</span></span><span class=line><span class=cl>* master
</span></span><span class=line><span class=cl>  remotes/origin/master
</span></span><span class=line><span class=cl>  remotes/origin/secondary
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ git branch -r 
</span></span><span class=line><span class=cl>  origin/master
</span></span><span class=line><span class=cl>  origin/secondary
</span></span></code></pre></div><p>删除远程仓库中的分支</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git push origin --delete &lt;branch-name&gt;
</span></span></code></pre></div><h3 id=5将本地分支推送到远程>5.将本地分支推送到远程<a hidden class=anchor aria-hidden=true href=#5将本地分支推送到远程>#</a></h3><p>我们也可以将本地新分支的变更推送到远程 repo。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git checkout -b local-new-branch
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl><span class=o>(</span><span class=k>do</span> some changes to README.md<span class=o>)</span>
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ git commit -a -m <span class=s2>&#34;Update from local-new-branch&#34;</span>
</span></span><span class=line><span class=cl><span class=o>[</span>local-new-branch 40e9ee3<span class=o>]</span> Update: local-new-branch
</span></span><span class=line><span class=cl> <span class=m>1</span> file changed, <span class=m>2</span> insertions<span class=o>(</span>+<span class=o>)</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>$ git push origin local-new-brancch
</span></span><span class=line><span class=cl>Enumerating objects: 5, <span class=k>done</span>.
</span></span><span class=line><span class=cl>Counting objects: 100% <span class=o>(</span>5/5<span class=o>)</span>, <span class=k>done</span>.
</span></span><span class=line><span class=cl>Delta compression using up to <span class=m>8</span> threads
</span></span><span class=line><span class=cl>Compressing objects: 100% <span class=o>(</span>3/3<span class=o>)</span>, <span class=k>done</span>.
</span></span><span class=line><span class=cl>Writing objects: 100% <span class=o>(</span>3/3<span class=o>)</span>, <span class=m>334</span> bytes <span class=p>|</span> 334.00 KiB/s, <span class=k>done</span>.
</span></span><span class=line><span class=cl>Total <span class=m>3</span> <span class=o>(</span>delta 2<span class=o>)</span>, reused <span class=m>0</span> <span class=o>(</span>delta 0<span class=o>)</span>, pack-reused <span class=m>0</span>
</span></span><span class=line><span class=cl>remote: Resolving deltas: 100% <span class=o>(</span>2/2<span class=o>)</span>, completed with <span class=m>2</span> <span class=nb>local</span> objects.
</span></span><span class=line><span class=cl>remote: 
</span></span><span class=line><span class=cl>remote: Create a pull request <span class=k>for</span> <span class=s1>&#39;local-new-branch&#39;</span> on GitHub by visiting:
</span></span><span class=line><span class=cl>remote:      https://github.com/<span class=o>[</span>username<span class=o>]</span>/myproject/pull/new/local-new-branch
</span></span><span class=line><span class=cl>remote: 
</span></span><span class=line><span class=cl>To https://github.com/<span class=o>[</span>username<span class=o>]</span>/myproject.git
</span></span><span class=line><span class=cl> * <span class=o>[</span>new branch<span class=o>]</span>      local-new-branch -&gt; local-new-branch
</span></span></code></pre></div><p>现在，如果我们访问 github 远程仓库，就会发现有一个新推送的分支，名为 local-new-branch</p><h3 id=6merge-into-master>6.Merge Into Master<a hidden class=anchor aria-hidden=true href=#6merge-into-master>#</a></h3><p>如上所述，在 github repo 页面上，我们希望将本地-新分支中的更改合并到主分支中。网页上有 " <strong>Compare & Pull Request</strong>.&ldquo;选项。</p><p>我们可以点击它并创建一个<strong>pull request</strong>请求。</p><p>因为这是我们自己的 repo，所以我们是 &ldquo;权威&rdquo;，可以直接点击 &ldquo;<strong>Merge pull request</strong> &ldquo;将更改合并到主分支。</p><p>但在现实生活中，拉取请求通常需要经过代码审查和测试流程，并由合作者验证。如果获得批准，拉取请求才会通过并被合并。</p><h3 id=7clone-and-fork>7.clone and fork<a hidden class=anchor aria-hidden=true href=#7clone-and-fork>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git clone <span class=o>[</span>the repo url<span class=o>]</span> <span class=o>[</span>the folder path we want to clone into<span class=o>]</span>
</span></span></code></pre></div><h3 id=8git-ignore>8.Git Ignore<a hidden class=anchor aria-hidden=true href=#8git-ignore>#</a></h3><p>我们并不一定希望 git 追踪本地仓库中的每一个文件。可能有一些日志文件、临时文件或个人文件不应该被纳入 git 工作流。</p><p>为了解决这个问题，我们可以在 git 仓库中创建一个 .gitignore 文件，这样 git 就会忽略其中指定的文件。不过，.gitignore 文件本身会被 git 追踪。</p><p>常见的用法包括</p><table><thead><tr><th>command</th><th>Description</th></tr></thead><tbody><tr><td></td><td>blank lines are ignored</td></tr><tr><td># something</td><td>lines start with # is comment and ignored</td></tr><tr><td><em>name</em></td><td>All <em>name</em> files and folders</td></tr><tr><td><em>name/</em></td><td>All folders called <em>name</em></td></tr><tr><td><em>name.file</em></td><td>All <em>name.file</em> in repo</td></tr><tr><td>*<em>.file</em></td><td>any file with extension <em>.file</em></td></tr><tr><td><em>!*.file</em></td><td>negate any previous ignore on this file</td></tr></tbody></table><h3 id=8remove-origin>8.remove origin<a hidden class=anchor aria-hidden=true href=#8remove-origin>#</a></h3><p>使用下面命令可将指向仓库的远程 URL 先去除，就能添加其他仓库的地址</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git remote remove origin
</span></span><span class=line><span class=cl>git remote add origin https://github.com/xxx
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://dueplay.github.io/tags/git/>Git</a></li></ul><nav class=paginav><a class=prev href=https://dueplay.github.io/posts/chrono/><span class=title>« Prev</span><br><span>chrono库的使用</span>
</a><a class=next href=https://dueplay.github.io/posts/ssh%E6%96%B9%E5%BC%8Fa%E4%B8%BB%E6%9C%BA%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95b/><span class=title>Next »</span><br><span>配置ssh免密登录</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://dueplay.github.io/>Cookie's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>