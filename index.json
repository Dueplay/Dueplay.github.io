[{"content":"catch2用法 定义测试案例 测试案例在 Catch2 中通过 TEST_CASE 宏定义。TEST_CASE 宏接受两个参数：测试案例的名称和一个可选的标签。\n#define CATCH_CONFIG_MAIN // 这行让 Catch 自己提供一个 main() 函数 #include \u0026lt;catch2/catch.hpp\u0026gt; TEST_CASE(\u0026#34;A test case\u0026#34;, \u0026#34;[tag]\u0026#34;) { REQUIRE(1 == 1); } 如果你有多个测试文件，只需要在一个文件中定义 CATCH_CONFIG_MAIN。\n断言 Catch2 提供了多种断言宏，最常用的是 REQUIRE 和 CHECK：\nREQUIRE：如果断言失败，当前的测试案例会立即停止。 CHECK：即使断言失败，当前的测试案例也会继续运行，允许多个断言失败。 TEST_CASE(\u0026#34;Testing addition\u0026#34;) { REQUIRE(1 + 1 == 2); CHECK(2 + 2 == 4); } 测试固件 测试固件允许你在每个测试案例之前和之后运行一些代码。测试固件允许你设置和清理测试环境，这对于需要在多个测试案例中重用相同的初始化和清理逻辑非常有用。测试固件通过定义一个结构体或类来实现，你可以在其中定义构造函数（用于设置）和析构函数（用于清理）。然后，使用 TEST_CASE_METHOD 宏来指定哪个固件类应该被用于哪个测试案例。\nstruct DatabaseFixture { Database db; DatabaseFixture() : db(\u0026#34;my_database\u0026#34;) { // 初始化代码，比如打开数据库连接 db.connect(); } ~DatabaseFixture() { // 清理代码，比如关闭数据库连接 db.disconnect(); } }; // 一旦定义了测试固件，就可以在 TEST_CASE_METHOD 宏中使用它 TEST_CASE_METHOD(DatabaseFixture, \u0026#34;Test database connection\u0026#34;, \u0026#34;[database]\u0026#34;) { REQUIRE(db.isConnected() == true); } TEST_CASE_METHOD(DatabaseFixture, \u0026#34;Test database query\u0026#34;, \u0026#34;[database]\u0026#34;) { REQUIRE(db.query(\u0026#34;SELECT * FROM users\u0026#34;).size() \u0026gt; 0); } 在上述代码中，每个 TEST_CASE_METHOD 调用都会创建 DatabaseFixture 的一个新实例，这意味着每个测试案例都会开始于一个已连接的数据库状态。测试完成后，析构函数会被调用以断开连接，保证了每个测试都是独立的。\n分节 Catch2 允许你在单个测试案例中定义分节（Section），这些分节可以共享设置代码，但是每个分节会独立运行。\n这意味着在进入每个 SECTION 前，TEST_CASE 中定义的代码会被执行，为每个 SECTION 提供了一个共同的起点或环境。\n#define CATCH_CONFIG_MAIN #include \u0026lt;catch2/catch.hpp\u0026gt; TEST_CASE(\u0026#34;Testing with shared setup code\u0026#34;, \u0026#34;[example]\u0026#34;) { // 这里是共享的设置代码 int value = 42; SECTION(\u0026#34;Test part 1\u0026#34;) { // 第一个测试部分可以使用共享的设置代码 REQUIRE(value == 42); } SECTION(\u0026#34;Test part 2\u0026#34;) { // 第二个测试部分也可以使用相同的设置代码 value += 58; REQUIRE(value == 100); } } 变量 value 的初始化就是所谓的“设置代码”，它在两个不同的测试节中被共享。每个 SECTION 都独立执行，这意味着每个 SECTION 都会从 TEST_CASE 的开始处执行，包括共享的设置代码。因此，即便是在不同的测试节中，value 也总是从初始值 42 开始。\n参数化测试 Catch2 支持参数化测试，使得你可以用不同的输入重复运行同一测试案例。GENERATE 宏能够为测试案例生成一系列的值。在每次测试迭代中，GENERATE 会提供一个值，然后测试案例会使用这个值执行。这意味着相同的测试逻辑会被重复执行，但每次都使用不同的输入值。\n#define CATCH_CONFIG_MAIN #include \u0026lt;catch2/catch.hpp\u0026gt; TEST_CASE(\u0026#34;Parameterized tests with GENERATE\u0026#34;, \u0026#34;[example]\u0026#34;) { // 使用 GENERATE 宏生成一系列测试数据 int input = GENERATE(1, 2, 3, 4, 5); // 使用生成的数据执行测试逻辑 REQUIRE(input \u0026lt; 6); } 在这个例子中，GENERATE(1, 2, 3, 4, 5) 会依次为变量 input 生成 1 到 5 的值。对于每个生成的值，REQUIRE(input \u0026lt; 6) 断言都会被执行一次。因此，这个测试案例会被执行五次，每次使用不同的 input 值。\n集成catch2到cmake v2.xx的版本只需要catch2.hpp这个头文件就行了\nv3.xx的版本的用法：链接到Catch2::Catch2WithMain\ncmake_minimum_required(VERSION 3.14) # 确保使用的是 FetchContent 可用的 CMake 版本 project(MyProject VERSION 1.0) include_directories(${PROJECT_SOURCE_DIR}/include) # 包含 FetchContent 模块 include(FetchContent) # 使用 FetchContent_Declare 声明 Catch2 作为外部依赖项 FetchContent_Declare( Catch2 GIT_REPOSITORY https://github.com/catchorg/Catch2.git GIT_TAG v3.3.0 # or a later release ) # 使 Catch2 可用 FetchContent_MakeAvailable(Catch2) # 添加你的项目文件（示例） add_executable(my_project src/main.cpp src/sub.cpp) # 如果你有测试代码，可以像这样设置 enable_testing() # 启用测试 # 添加测试可执行文件 add_executable( my_test test/test1.cpp test/test2.cpp # 添加其他测试文件 ) # 链接 Catch2 到测试可执行文件 target_link_libraries(my_test PRIVATE Catch2::Catch2WithMain) # 为 Catch2 配置测试发现 LIST(APPEND CMAKE_MODULE_PATH ${catch2_SOURCE_DIR}/extras) include(CTest) include(Catch) CATCH_DISCOVER_TESTS(my_test) ","permalink":"https://dueplay.github.io/posts/catch2/","summary":"catch2用法 定义测试案例 测试案例在 Catch2 中通过 TEST_CASE 宏定义。TEST_CASE 宏接受两个参数：测试案例的名称和一个可选的标签。\n#define CATCH_CONFIG_MAIN // 这行让 Catch 自己提供一个 main() 函数 #include \u0026lt;catch2/catch.hpp\u0026gt; TEST_CASE(\u0026#34;A test case\u0026#34;, \u0026#34;[tag]\u0026#34;) { REQUIRE(1 == 1); } 如果你有多个测试文件，只需要在一个文件中定义 CATCH_CONFIG_MAIN。\n断言 Catch2 提供了多种断言宏，最常用的是 REQUIRE 和 CHECK：\nREQUIRE：如果断言失败，当前的测试案例会立即停止。 CHECK：即使断言失败，当前的测试案例也会继续运行，允许多个断言失败。 TEST_CASE(\u0026#34;Testing addition\u0026#34;) { REQUIRE(1 + 1 == 2); CHECK(2 + 2 == 4); } 测试固件 测试固件允许你在每个测试案例之前和之后运行一些代码。测试固件允许你设置和清理测试环境，这对于需要在多个测试案例中重用相同的初始化和清理逻辑非常有用。测试固件通过定义一个结构体或类来实现，你可以在其中定义构造函数（用于设置）和析构函数（用于清理）。然后，使用 TEST_CASE_METHOD 宏来指定哪个固件类应该被用于哪个测试案例。\nstruct DatabaseFixture { Database db; DatabaseFixture() : db(\u0026#34;my_database\u0026#34;) { // 初始化代码，比如打开数据库连接 db.connect(); } ~DatabaseFixture() { // 清理代码，比如关闭数据库连接 db.","title":"catch2测试框架"},{"content":"实验中给出的 B+ 树接口非常简单，基本只有查询、插入和删除三个接口，内部基本没有给出别的辅助函数，可以让我们自由发挥（无从下手）。因此，任何合法的 B+ 树实现都是允许的。\nB+ 树索引在 Bustub 中的位置如图所示:\nB+树种需要的page都需要使用在 Project 1 中实现的 buffer pool manager 来获取。\nCheckpoint1 Single Thread B+Tree Checkpoint1 分为两个部分：\nTask1: B+Tree pages，B+树中的各种 page。在 Bustub 索引 B+ 树中，所有的节点都是一个 page。包含 leaf page，internal page ，和它们的父类 tree page。 Task2：B+Tree Data Structure (Insertion, Deletion, Point Search)。Checkpoint1 的重点，即 B+树的插入、删除和单点查询。 Task1 B+Tree Pages task1 主要实现leaf page和internal page这两个类，都继承自BPlusTreePage这个父类，实现一些Getter和Setter方法。\n首先介绍一下page的内存布局\n其中，data_ 是实际存放 page 数据的地方，大小为 BUSTUB_PAGE_SIZE，为 4KB。其他的成员是 page 的 metadata。\nB+树中的 tree page 数据均存放在 page 的 data 成员中，也就是B+树中的节点是Page的data数据成员。\nB_PLUS_TREE_PAGE\nheader包括以下数据\nIndexPageType page_type_; // leaf or internal. 4 Byte lsn_t lsn_ // temporarily unused. 4 Byte int size_; // tree page data size(not in byte, in count). 4 Byte int max_size_; // tree page data max size(not in byte, in count). 4 Byte page_id_t parent_page_id_; // 4 Byte page_id_t page_id_; // 4 Byte // 24 Byte in total page data 的 4KB 中，24Byte 用于存放 header，剩下的则用于存放 tree page 的数据，即 KV 对。\nB_PLUS_TREE_INTERNAL_PAGE\n对应 B+ 树中的内部节点。\nMappingType array_[1]; internal page 中没有新的 metadata，header 大小仍为 24B。它唯一的成员是一个大小为 1 的数组。大小为 1 显然不合理，代表只能存放一个 KV 对。但又没法改变它的大小，难道要用 undefined behavior 来越界访问其后的地址？实际上差不多就是这个意思。但这不是 undefined behavior，是一种特殊的写法，叫做 flexible array。\n简单来说就是，当你有一个类，这个类中有一个成员为数组。在用这个类初始化一个对象时，你不能确定该将这个数组的大小设置为多少，但知道这整个对象的大小是多少 byte，你就可以用到 flexible array。flexible array 必须是类中的最后一个成员，并且仅能有一个。在为对象分配内存时，flexible array 会自动填充，占用未被其他变量使用的内存。这样就可以确定自己的长度了。\n例如有一个类 C：\nclass C { int a; // 4 byte int array[1]; // unknown size }; 现在初始化一个 C 的对象，并为其分配了 24 byte 的内存。a 占了 4 byte 内存，那么 array 会尝试填充剩下的内存，大小变为 5。\n实际上这就是 C++ 对象内存布局的一个简单的例子。因此 flexible array 为什么只能有一个且必须放在最后一个就很明显了，因为需要向后尝试填充。\n这个大小为 1 的数组的作用就比较清楚了。利用 flexible array 的特性来自动填充 page data 4KB 减掉 header 24byte 后剩余的内存。剩下的这些内存用来存放 KV 对。\ninternal page 中，KV 对的 K 是能够比较大小的索引，V 是 page id，用来指向下一层的节点。Project 中要求，第一个 Key 为空。主要是因为在 internal page 中，n 个 key 可以将数轴划分为 n+1 个区域，也就对应着 n+1 个 value。实际上你也可以把最后一个 key 当作是空的。\n通过比较 key 的大小选中下一层的节点。实际上等号的位置也可以改变，总之，只要是合法的 B+ 树，即节点大小需要满足最大最小值的限制，各种实现细节都是自由的。\n另外需要注意的是，internal page 中的 key 并不代表实际上的索引值，实际的KV在B+树中都存在leaf page中，这里仅仅是作为一个向导，引导需要插入/删除/查询的 key 找到这个 key 真正所在的 leaf page。\nB_PLUS_TREE_LEAF_PAGE\nleaf page 和 internal page 的内存布局基本一样，只是 leaf page 多了一个成员变量 next_page_id，指向下一个 leaf page（用于 range scan）。因此 leaf page 的 header 大小为 28 Byte。\nleaf page 的 KV 对中，K 是实际的索引，V 是 record id。record id (table_id + slot_id)用于标识表中的某一条数据。leaf page 的 KV 对是一一对应的，不像 internal page 的一个key可以有多个 value 。这里也可以看出来 Bustub 所有的 B+ 树索引，无论是主键索引还是二级索引都是非聚簇索引。\n这里简单介绍一下聚簇索引、非聚簇索引，主键索引、二级索引（非主键索引）的区别。 在聚簇索引里，leaf page 的 value 为表中一条数据的某几个字段或所有字段，一定包含主键字段。而非聚簇索引 leaf page 的 value 是 record id，即指向一条数据的指针。 在使用聚簇索引时，主键索引的 leaf page 包含所有字段，二级索引的 leaf page 包含主键和索引字段。当使用主键查询时，查询到 leaf page 即可获得整条数据。当使用二级索引查询时，若查询字段包含在索引内，可以直接得到结果，但如果查询字段不包含在索引内，则需使用得到的主键字段在主键索引中再次查询，以得到所有的字段，进而得到需要查询的字段，这就是回表的过程。 在使用非聚簇索引时，无论是使用主键查询还是二级索引查询，最终得到的结果都是 record id，需要使用 record id 去查询真正对应的整条记录。 聚簇索引的优点是，整条记录直接存放在 leaf page，无需二次查询，且缓存命中率高，在使用主键查询时性能比较好。缺点则是二级索引可能需要回表，且由于整条数据存放在 leaf page，更新索引的代价很高，页分裂、合并等情况开销比较大。 非聚簇索引的优点是，由于 leaf page 仅存放 record id，更新的代价较低，二级索引的性能和主键索引几乎相同。缺点是查询时均需使用 record id 进行二次查询。\nTask2 B+Tree Data Structure (Insertion, Deletion, Point Search) Search\nB+ 树的节点分为 internal page 和 leaf page，每个 page 上的 key 有序排列。当拿到一个 key 需要查找对应的 value 时，首先需要经由 internal page 递归地向下查找，最终找到 key 所在的 leaf page。这个过程可以简化为一个函数 FindLeafPage()。\nFindLeafPage() 从 root page 开始一层一层的查找。在查找到 leaf page 时直接返回，否则根据 key 在当前 internal page 中找到对应的 child page id，再在child page 中查找。由于 key 是有序的，可以直接进行二分搜索。\ninternal page 中储存 key 和 child page id，那么在拿到 page id 后如何获得对应的 page 指针？用 Project 1 中实现的 buffer pool。\nPage *page = buffer_pool_manager_-\u0026gt;FetchPage(page_id); 在获取到一个 page 后，如何使用这个 page 来存储数据？之前已经提到过，page 的 data_ 字段是实际用于存储数据的 4KB 大小的字节数组。通过 reinterpret_cast 将这个字节数组强制转换为我们要使用的类型，例如 leaf page：\nauto leaf_page = reinterpret_cast\u0026lt;B_PLUS_TREE_LEAF_PAGE_TYPE *\u0026gt;(page-\u0026gt;GetData()) reinterpret_cast 用于无关类型的强制转换，转换方法很简单，原始 bits 不变，只是对这些 bits 用新类型进行了重新的解读。可想而知这种转换非常不安全，需要确保转换后的内存布局仍是合法的。在这里原类型是 byte 数组，新类型是我们需要使用的 tree page。\n我们可以将上面两部封装成一个函数，用于根据page_id获取BPlusTreePage原始的page和page.data。注意这里reinterpret_cast返回的是BPlusTreePage，后续还需要转成其子类leaf和interal page。。\nINDEX_TEMPLATE_ARGUMENTS auto BPLUSTREE_TYPE::FetchBPlusTreePage(page_id_t page_id) -\u0026gt; std::pair\u0026lt;Page *, BPlusTreePage *\u0026gt; { Page *page = buffer_pool_manager_-\u0026gt;FetchPage(page_id); BUSTUB_ASSERT(page != nullptr, \u0026#34;FetchBPlusTreePage(): page != nullptr\u0026#34;); return {page, reinterpret_cast\u0026lt;BPlusTreePage *\u0026gt;(page-\u0026gt;GetData())}; } 找到 leaf page 后，同样是二分查找 key，找到对应的 record id。注意在leaf page中二分查找左边界是0，在internal page中二分查找左边界是1。\n在查找的时候还有一个比较重要且复杂的细节，就是 page unpin 的问题。\n我们在拿到 page id 后，调用 buffer pool 的 FetchPage() 函数来获取对应的 page 指针。要注意的是，在使用完 page 之后，需要将 page unpin 掉，否则最终会导致 buffer pool 中的所有 page 都被 pin 住，buffer pool 满无法进行换入换出，无法从 disk 读取其他的 page。\n比较合适的做法是，在本次操作中，找出 page 最后一次被使用的地方，并在最后一次使用后 unpin。\nInsert\n与 Search 相同，第一步是根据 key 找到需要插入的 leaf page。同样是调用 FindLeafPage()。得到 leaf page 后，将 key 插入 leaf page。当B+树为空时，新建一个leaf page作为root page将其插入。要注意的是：1.插入时仍需保证 key 的有序性，同样可以二分搜索找到合适的位置插入。2.是不允许有重复的key的，当插入重复的key返回false。\n在插入后，需要检查当前 leaf page size 是否等于 max size。若相等，则要进行一次 leaf page 分裂操作。具体步骤为：\n新建一个空的 page， 将原 page 的一半转移到新 page 中，（假如选择将新 page 放在原 page 右侧，则转移原 page 的右半部分） 更新原 page 和新 page 的 next page id， 获取 parent page，将用于区分原 page 和新 page 的 key 插入 parent page 中， 更新 parent page 所有 child page 的父节点指针。 需要给 parent page 插入一个新 key 的原因是，多了一个子节点，自然需要多一个 key 来区分，这个key是右边节点的key0。其中第 4 步是重点。获取 parent page 并不是简单地通过当前 page 的 parent id 来获取，因为 parent page 也可能发生分裂。\n假如我们有一棵 5 阶的 B+ 树。5 阶只是一种常用的说法，代表 B+ 树节点最多能容纳五个 KV 对。对于 leaf page 来说，当 B+ 树处于稳定状态时（插入、删除等操作已经完全结束），最多只能有 4 个 KV 对。对于 internal page，最多有 4 个 key，5 个 value，可以看成是有 5 个 KV 对。\n因此，instruction 中有这么一句话：\nYou should correctly perform splits if insertion triggers the splitting condition (number of key/value pairs AFTER insertion equals to max_size for leaf nodes, number of children BEFORE insertion equals to max_size for internal nodes.).\n在插入后检测 leaf page 是否需要分裂，因为 leaf page 稳定时只有 4 个 KV 对，插入后有 5 个，仍能容纳。在插入前检测 internal page，因为 internal page 稳定时就有 5 个 KV 对，若插入后再检测，插入的第 6 个 KV 对会造成越界。\n实际上这也只是一种约定，并不是强制的规则。\n第 4 步具体操作如下： 1. 根据leaf page的 parent page id 拿到 parent page， 2. 判断 parent page size 是否等于 max size，（插入前检查） 3. 若小于，直接返回 parent page， 4. 否则，分裂当前 internal page。并根据此后需要插入的 key 选择分裂后的两个 page 之一作为 parent page 返回。\n分裂 internal page 的步骤为： 1. 新建一个空的 InternalPage， 2. 将原 page 的一半转移到新 page 中，需要注意原 page 和新 page 的第一个 key 都是无效的， 3. 更新新 page 所有 child page 的父节点指针，指向新 page， 4. 获取 parent page， 5. 将用于区分原 page 和新 page 的 key 插入 parent page 中， 6. 更新 parent page 所有 child page 的父节点指针。\n这里发生了向上的递归，直到遇到安全的父节点或者遇到根节点。在遇到根节点时，若根节点也需要分裂，则除了需要新建一个节点用来容纳原根节点一半的 KV 对，还需要新建一个新的根节点。\n假如有一棵 4 阶的 B+ 树：\nDelete\n同样地，先找到 leaf page。删除 leaf page 中 key 对应的 KV 对后，检查 size 是否小于 min size。如果小于的话，首先尝试从两侧的兄弟节点中偷一个 KV 对。注意只能从兄弟节点，即父节点相同的节点中选取。假如存在一侧节点有富余的 KV 对，则成功偷取，结束操作。若两侧都没有富余的 KV 对，则选择一侧节点与其合并。\n偷取的过程比较简单，从左侧节点偷取时，把左侧节点最后一个 KV 对转移至当前节点第一个 KV 对，从右侧节点偷取时，把右侧节点的 KV 对转移至当前节点最后一个 KV 对。leaf page 和 internal page 的偷取过程基本相同，仅需注意 internal page 偷取后更新子节点的父节点指针。\n稍难的是合并的过程。同样，任选左右侧一兄弟节点进行合并。将一个节点的所有 KV 对转移至另一节点。若合并的是 leaf page，记得更新 next page id。若合并的是 internal page，记得更新合并后 page 的子节点的父节点指针。然后，删除 parent 节点中对应的 key。删除后，再次检查 size 是否小于 min size，形成向上递归。\n需要注意的是，root page 并不受 min size 的限制。但如果 root page 被删到 size 只剩 1，即只有一个 child page 的时候，应将此 child page 设置为新的 root page。\n另外，在合并时，两个 page 合并成一个 page，另一个 page 应该删除，释放资源。删除 page 时，仍是调用 buffer pool 的 DeletePage() 函数。\n和 Insert 类似，Delete 过程也是先向下递归查询 leaf page，不满足 min size 后先尝试偷取，无法偷取则合并，并向上递归地检查是否满足 min size。\n","permalink":"https://dueplay.github.io/posts/bustub-project2/","summary":"实验中给出的 B+ 树接口非常简单，基本只有查询、插入和删除三个接口，内部基本没有给出别的辅助函数，可以让我们自由发挥（无从下手）。因此，任何合法的 B+ 树实现都是允许的。\nB+ 树索引在 Bustub 中的位置如图所示:\nB+树种需要的page都需要使用在 Project 1 中实现的 buffer pool manager 来获取。\nCheckpoint1 Single Thread B+Tree Checkpoint1 分为两个部分：\nTask1: B+Tree pages，B+树中的各种 page。在 Bustub 索引 B+ 树中，所有的节点都是一个 page。包含 leaf page，internal page ，和它们的父类 tree page。 Task2：B+Tree Data Structure (Insertion, Deletion, Point Search)。Checkpoint1 的重点，即 B+树的插入、删除和单点查询。 Task1 B+Tree Pages task1 主要实现leaf page和internal page这两个类，都继承自BPlusTreePage这个父类，实现一些Getter和Setter方法。\n首先介绍一下page的内存布局\n其中，data_ 是实际存放 page 数据的地方，大小为 BUSTUB_PAGE_SIZE，为 4KB。其他的成员是 page 的 metadata。\nB+树中的 tree page 数据均存放在 page 的 data 成员中，也就是B+树中的节点是Page的data数据成员。","title":"bustub project2"},{"content":"buffer pool是负责在内存和磁盘之间移动页面(数据库文件是以页来组织的)。buffer pool的操作对于系统的其他组件是 透明的，也就是说系统只需要使用一个page_id（这是唯一的）去像buffer pool请求这个页面，是不知道这个页是不是已经在内存中了，还是需要从磁盘中读。\n可拓展hash table 第一个任务是需要实现一个可拓展hash table，这个hash table的作用是负责管理page_id到buffer pool中页面id(frame_id)的映射。buffer pool管理N个页面的内存空间，一个页面的内存空间就叫做frame。需要读取一个页面时，就将一个frame分配这个页面，然后用hash table记录这个映射关系。\n在实现之前需要理解一些可拓展哈希表中的概念：[参考文献](Extendible Hashing (Dynamic approach to DBMS) - GeeksforGeeks)\n目录dir：这个容器存储指向桶的指针。每个dir给定一个唯一的id，当扩张发生时id可能随之改变。哈希函数返回这个目录的id，这个id被用来指向合适的桶。dir的数量 = 2^{全局深度} 桶: 存储哈希键。目录指向桶。如果局部深度小于全局深度时，一个桶可能包含不止一个指针指向它。 全局深度：它跟目录相关联。它们表示哈希函数使用的比特位数目去分类这些键。全局深度=目录id的比特位数 局部深度：和全局深度类似，局部深度是跟桶关联，而不是跟目录。当桶溢出发生时，局部深度根据全局深度去决定执行的行为。局部深度通常小于等于全局深度。 桶分裂：当桶的元素超过了特定的大小，那么桶分裂成两个部分。 目录扩容：当桶溢出时，可能会有目录扩容。当溢出桶的局部深度等于全局深度时，目录扩容被执行。 首先需要实现的是Bucket，Bucket采用的std::list\u0026lt;pair\u0026lt;K,V\u0026raquo;来作为存储数据的数据结构，stl可以让我们很方便的实现数据的增删查改。查找一个key可以通过std::find_if或者遍历这个list，插入时需要判断是否超出这个桶的大小。\n有了Bucket，就可以开始实现我们的可拓展hash表，它的全局深度首先被初始化为0，由于桶的数量是2^全局深度，所以在开始时只有一个桶，即dir中只有一个Bucket指针。\n重点是insert操作(插入一个key，value对)的实现。首先是根据hash函数计算出key的dir index，然后再在对应的桶中实现插入。在插入到桶中时可能因为桶已满而插入失败，这时候我们就需要进行目录扩张和桶分裂。需要注意的是：并不是桶满了就需要执行目录的分裂，而是当桶的局部深度=全局深度时，才需要进行桶的分裂。在桶的局部深度小于全局深度时是不需要扩张目录的，此时是有多个指针指向同一个桶，我们只需要再创建一个新桶，然后再将这个已满桶中的元素重新分配即可，创建新桶需要将局部深度+1。在桶扩张时，将新扩张的dir(桶指针)指向同一个桶，当需要时再去创建新的桶。\neg: global_depth = 2, local_depth = 2, dir_size = 2^2 = 4，插入kv到idx = 3 的桶，但这个桶已经满了。则需要执行dir扩张，扩张为原来的2倍，即dir_size = 2^2* \u0026laquo; 1,扩张为8。idx = 3 = 011，3 + old_dir_size = 7 = 111，7的位置则是新建的桶。其他新扩张应该指向之前的桶，等到之间的桶满，再创建。即4指向0指向的桶，等等。\n由于是要支持并发操作的，因此也需要在合适的地方加锁。\n造成死锁的一种情况：当一个函数中已经加锁再去调用另一个需要同一把锁的函数，这会造成死锁。\nlru_k替换策略 在frame中page，在整个buffer pool中的所有frame都被使用时，这时候则需要选择一个victim来替换。常使用的是lru算法，lru_k则是再lru的基础上多加了一个访问k次以上的页，是要比那些小于k次更晚被换出。简单的理解就是，将所有在frame中的页面分为访问小于k次的和大于等于k次的，两种都是采用lru算法，但是是先替换小于k次的页面，小于k次页面的全部不能被替换或者当没有小于k次还需要Evict一个page时，才去Evict一个大于k次的页面。\n不能被替换的page是那些被pin的，也就是还在使用的page。\nstd::vector\u0026lt;LRUKFrameRecord *\u0026gt; frames_ 记录buffer pool中所有frame的一个访问记录，LRUKFrameRecord 是记录一个frame的最多k次访问记录。\n我们可以set来将所有可被Evict的frame分为小于k次的一个set，和大于等于k次的一个set，并且重载LRUKFrameRecord 的operator\u0026lt;，使其访问时间最早的在set的最前面，Evict时则选择set.begind()的frame。不可被Evict的frame不应该出现在set中，不能被lru的机制所Evict。\nSetEvictable这个函数将一个frame设置为可不可被Evict, 一种情况是将不可被Evict设置为可Evict，需要再对应的set中加入；一种是可Evict设置为不可Evict，需要将其在对应的set中移除。\nbuffer_pool_manager_instance bpm则将上面实现的组件协同起来实现整个buffer_pool的逻辑。\nbpm管理着一个std::list\u0026lt;frame_id_t\u0026gt; free_list_, 记录着未被使用的frame，free_list_为空时，则需要用lru_k替换一个frame。\nNewPgImp需要在buffer pool中创建page_id的page，如果free_list_为空时，则需要用lru_k替换一个frame。替换这个frame如果他的状态是dirty的，则需要调用disk_manager将其写回。创建新page后，需要用hash table记录其对应的frame，以及需要记录访问记录以上lru_k替换器来管理。\nFetchPgImp在buffer pool中获取指定page_id的页面，存在则直接获取，同时记录访问和pin++,并且设置不可Evict。若不存在，则需要像newPage一样。\nfetch 和 newpage的区别是：new是在buffer pool中加入一个新的页面，而fetch是获得在buffer pool中已有的页面,没有再尝试evict a frame and read page_id page from disk\n","permalink":"https://dueplay.github.io/posts/bustub-project1/","summary":"buffer pool是负责在内存和磁盘之间移动页面(数据库文件是以页来组织的)。buffer pool的操作对于系统的其他组件是 透明的，也就是说系统只需要使用一个page_id（这是唯一的）去像buffer pool请求这个页面，是不知道这个页是不是已经在内存中了，还是需要从磁盘中读。\n可拓展hash table 第一个任务是需要实现一个可拓展hash table，这个hash table的作用是负责管理page_id到buffer pool中页面id(frame_id)的映射。buffer pool管理N个页面的内存空间，一个页面的内存空间就叫做frame。需要读取一个页面时，就将一个frame分配这个页面，然后用hash table记录这个映射关系。\n在实现之前需要理解一些可拓展哈希表中的概念：[参考文献](Extendible Hashing (Dynamic approach to DBMS) - GeeksforGeeks)\n目录dir：这个容器存储指向桶的指针。每个dir给定一个唯一的id，当扩张发生时id可能随之改变。哈希函数返回这个目录的id，这个id被用来指向合适的桶。dir的数量 = 2^{全局深度} 桶: 存储哈希键。目录指向桶。如果局部深度小于全局深度时，一个桶可能包含不止一个指针指向它。 全局深度：它跟目录相关联。它们表示哈希函数使用的比特位数目去分类这些键。全局深度=目录id的比特位数 局部深度：和全局深度类似，局部深度是跟桶关联，而不是跟目录。当桶溢出发生时，局部深度根据全局深度去决定执行的行为。局部深度通常小于等于全局深度。 桶分裂：当桶的元素超过了特定的大小，那么桶分裂成两个部分。 目录扩容：当桶溢出时，可能会有目录扩容。当溢出桶的局部深度等于全局深度时，目录扩容被执行。 首先需要实现的是Bucket，Bucket采用的std::list\u0026lt;pair\u0026lt;K,V\u0026raquo;来作为存储数据的数据结构，stl可以让我们很方便的实现数据的增删查改。查找一个key可以通过std::find_if或者遍历这个list，插入时需要判断是否超出这个桶的大小。\n有了Bucket，就可以开始实现我们的可拓展hash表，它的全局深度首先被初始化为0，由于桶的数量是2^全局深度，所以在开始时只有一个桶，即dir中只有一个Bucket指针。\n重点是insert操作(插入一个key，value对)的实现。首先是根据hash函数计算出key的dir index，然后再在对应的桶中实现插入。在插入到桶中时可能因为桶已满而插入失败，这时候我们就需要进行目录扩张和桶分裂。需要注意的是：并不是桶满了就需要执行目录的分裂，而是当桶的局部深度=全局深度时，才需要进行桶的分裂。在桶的局部深度小于全局深度时是不需要扩张目录的，此时是有多个指针指向同一个桶，我们只需要再创建一个新桶，然后再将这个已满桶中的元素重新分配即可，创建新桶需要将局部深度+1。在桶扩张时，将新扩张的dir(桶指针)指向同一个桶，当需要时再去创建新的桶。\neg: global_depth = 2, local_depth = 2, dir_size = 2^2 = 4，插入kv到idx = 3 的桶，但这个桶已经满了。则需要执行dir扩张，扩张为原来的2倍，即dir_size = 2^2* \u0026laquo; 1,扩张为8。idx = 3 = 011，3 + old_dir_size = 7 = 111，7的位置则是新建的桶。其他新扩张应该指向之前的桶，等到之间的桶满，再创建。即4指向0指向的桶，等等。\n由于是要支持并发操作的，因此也需要在合适的地方加锁。\n造成死锁的一种情况：当一个函数中已经加锁再去调用另一个需要同一把锁的函数，这会造成死锁。\nlru_k替换策略 在frame中page，在整个buffer pool中的所有frame都被使用时，这时候则需要选择一个victim来替换。常使用的是lru算法，lru_k则是再lru的基础上多加了一个访问k次以上的页，是要比那些小于k次更晚被换出。简单的理解就是，将所有在frame中的页面分为访问小于k次的和大于等于k次的，两种都是采用lru算法，但是是先替换小于k次的页面，小于k次页面的全部不能被替换或者当没有小于k次还需要Evict一个page时，才去Evict一个大于k次的页面。\n不能被替换的page是那些被pin的，也就是还在使用的page。\nstd::vector\u0026lt;LRUKFrameRecord *\u0026gt; frames_ 记录buffer pool中所有frame的一个访问记录，LRUKFrameRecord 是记录一个frame的最多k次访问记录。","title":"bustub project1"},{"content":"概览 需要实现一个数据结构为Trie树的kv存储，Trie一种高效的有序树数据结构，用于检索给定键的值。Trie中的每个节点存储一个key的单个字符，并且可以很多字节点，子节点代表key的下一个字符。key的末尾字符的节点(终端节点)会用一个flag标记这是一个key的结束，并存储相应的val。\n下面这个Trie树，有ab-\u0026gt;1,ac-\u0026gt;“val”，两个kv对，注意val可以是任何类型。\n实现 TrieNode TrieNode类代表树中的单个节点，代表一个key中的单个char。一个TrieNode可以有很多子节点，因此用unordered_map来存储每个子节点的字符和子节点指针的映射。此外还需要一个flag来表示该节点是否是一个key的结尾。为了避免内存泄露，采用智能指针。\nTrieNodeWithValue 该类代表一个key的终端节点，它继承了TrieNode，并且增加了自己特有的属性，即需要存储的val.\n可以有两种方式来创建终端节点：\n插入一个key，创建一个新的终端节点。 插入一个key，将非终端节点转换为终端节点，即将TrieNode转为TrieNodeWithValue。因此需要给该类实现一个TrieNodeWithValue(TrieNode \u0026amp;\u0026amp;trieNode, T value)有参构造，用于将已有的非终端节点转为终端节点，这个构造需要去调用TrieNode的移动构造将trieNode的资源转移到终端节点，包括表示的字符和子节点map。 Trie 成员变量有root节点的指针，指向一个根节点(用字符‘\\0’标识)；为了支持并发，还需要一个读写锁 ReaderWriterLatch latch_\n需要实现增删查三个功能\nInsert 插入一个kv对到Trie中，一个key的每个字符都是一个节点，因此需要做的就是从root节点开始，一层一层的插入新节点，如果有该字符的节点了，我们应该重用它。key最后一个字符需要特殊处理，而不是直接在父节点中插入新节点。\n需要判断是否该结尾字符已经在Trie树中，如果是，再判断这个节点是不是一个终端节点，如果是终端节点，则插入失败，因为不支持重复的key，如果不是终端节点，则需要将非终端的TrieNode转为终端节点TrieNodeWithValue。\n如果结尾字符不在Trie树中，创建新的TrieNodeWithValue，然后插入到父节点中，插入完成。\n同时在Insert操作中，应该是上写锁，返回时应该解锁。\nRemove 移除给定key的val，同时需要删除一些没用节点。首先是根据这个key从root开始一层一层遍历，找到该key的终端节点，没有该key对应的终端节点则直接返回false。找到终端节点后，将其flag设为false，表示这不是一个终端节点，逻辑上删除这个kv。下一步我们需要从该节点开始向上递归的删除那些没有任何子节点的非终端节点，因为这些节点肯定是不再会被用到的，既不是一个key的结尾，也不是一个key的中间节点。实现上可以通过从root开始将遍历到该节点的路径保存，然后在路径中从后往前遍历每个节点，判断是否属于这种情况，是则在其父节点的map中移除。\n同样的在Remove操作中，应该是上写锁，返回时应该解锁。\nGetValue 返回指定key对应的val，注意这个val的类型是任意的，所以这是一个函数模板。还是首先从根节点开始一层一层遍历key的每个字符找到最后一个字符所在的节点，然后不是终端节点或者没有该节点，失败直接返回。有这个key所对应的终端节点，那么返回这个终端节点的val。这样就ok了吗？其实不是，由于val是任意类型的，所以还需要判断这个val是不是我们所要的val类型。要检查这两个类型是否相同，将终端 TrieNode 通过dynamic_cast转为 TrieNodeWithValue。 如果转换结果不是 nullptr，则类型 T 是正确的类型。在类型不匹配时，即使有key所对应的终端节点，也应该失败直接返回。只有在类型匹配时，才正确返回其val。\n同样的在GetValue操作中，应该是上读锁，返回时应该解锁。\nReaderWriterLatch 在c++中可以通过std::shared_mutex mutex_很容易得实现一个读写锁。在bustub中已经有一个实现好的读写锁，上写锁mutex_.lock() ,上读锁mutex_.lock_shared(),对应的解锁操作分别是：mutex_.unlock() 和mutex_.unlock_shared()。\n源码 //===----------------------------------------------------------------------===// // // BusTub // // p0_trie.h // // Identification: src/include/primer/p0_trie.h // // Copyright (c) 2015-2022, Carnegie Mellon University Database Group // //===----------------------------------------------------------------------===// #pragma once #include \u0026lt;memory\u0026gt; #include \u0026lt;stdexcept\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;utility\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026#34;common/exception.h\u0026#34; #include \u0026#34;common/rwlatch.h\u0026#34; namespace bustub { /** * TrieNode is a generic container for any node in Trie. */ class TrieNode { public: /** * TODO(P0): Add implementation * * @brief Construct a new Trie Node object with the given key char. * is_end_ flag should be initialized to false in this constructor. * * @param key_char Key character of this trie node */ explicit TrieNode(char key_char) : key_char_(key_char), is_end_(false) {} /** * TODO(P0): Add implementation * * @brief Move constructor for trie node object. The unique pointers stored * in children_ should be moved from other_trie_node to new trie node. * * @param other_trie_node Old trie node. */ TrieNode(TrieNode \u0026amp;\u0026amp;other_trie_node) noexcept { key_char_ = other_trie_node.key_char_; // move semantics to transfer the ownership of unique_ptr // from other_trie_node to current one // 将容器中存储的元素全部移动到其他容器中。make_move_iterator返回一个move_iterator，若此迭代器用作输入迭代器，则效果是值被移动，而非复制。 children_ = std::unordered_map\u0026lt;char, std::unique_ptr\u0026lt;TrieNode\u0026gt;\u0026gt;(std::make_move_iterator(other_trie_node.children_.begin()), std::make_move_iterator(other_trie_node.children_.end())); other_trie_node.children_.clear(); } /** * @brief Destroy the TrieNode object. */ virtual ~TrieNode() = default; /** * TODO(P0): Add implementation * * @brief Whether this trie node has a child node with specified key char. * * @param key_char Key char of child node. * @return True if this trie node has a child with given key, false otherwise. */ bool HasChild(char key_char) const { return children_.find(key_char) != children_.end(); } /** * TODO(P0): Add implementation * * @brief Whether this trie node has any children at all. This is useful * when implementing \u0026#39;Remove\u0026#39; functionality. * * @return True if this trie node has any child node, false if it has no child * node. */ bool HasChildren() const { return !children_.empty(); } /** * TODO(P0): Add implementation * * @brief Whether this trie node is the ending character of a key string. * * @return True if is_end_ flag is true, false if is_end_ is false. */ bool IsEndNode() const { return is_end_; } /** * TODO(P0): Add implementation * * @brief Return key char of this trie node. * * @return key_char_ of this trie node. */ char GetKeyChar() const { return key_char_; } /** * TODO(P0): Add implementation * * @brief Insert a child node for this trie node into children_ map, given the * key char and unique_ptr of the child node. If specified key_char already * exists in children_, return nullptr. If parameter `child`\u0026#39;s key char is * different than parameter `key_char`, return nullptr. * * Note that parameter `child` is rvalue and should be moved when it is * inserted into children_map. * * The return value is a pointer to unique_ptr because pointer to unique_ptr * can access the underlying data without taking ownership of the unique_ptr. * Further, we can set the return value to nullptr when error occurs. * * @param key Key of child node * @param child Unique pointer created for the child node. This should be * added to children_ map. * @return Pointer to unique_ptr of the inserted child node. If insertion * fails, return nullptr. */ std::unique_ptr\u0026lt;TrieNode\u0026gt; *InsertChildNode(char key_char, std::unique_ptr\u0026lt;TrieNode\u0026gt; \u0026amp;\u0026amp;child) { if (HasChild(key_char) || child-\u0026gt;GetKeyChar() != key_char) { return nullptr; } children_[key_char] = std::move(child); return \u0026amp;(children_[key_char]); } /** * TODO(P0): Add implementation * * @brief Get the child node given its key char. If child node for given key * char does not exist, return nullptr. * * @param key Key of child node * @return Pointer to unique_ptr of the child node, nullptr if child * node does not exist. */ std::unique_ptr\u0026lt;TrieNode\u0026gt; *GetChildNode(char key_char) { if (!HasChild(key_char)) { return nullptr; } return \u0026amp;(children_.find(key_char)-\u0026gt;second); } /** * @brief Given a key char, if this child node already exists, return it. * If not exist, insert a new node into children map and then return it. * @param key_char Key of child node * @return Pointer to unique_ptr of the child node */ std::unique_ptr\u0026lt;TrieNode\u0026gt; *GetOrCreateChildNode(char key_char) { if (!HasChild(key_char)) { return InsertChildNode(key_char, std::make_unique\u0026lt;TrieNode\u0026gt;(key_char)); } return GetChildNode(key_char); } /** * TODO(P0): Add implementation * * @brief Remove child node from children_ map. * If key_char does not exist in children_, return immediately. * * @param key_char Key char of child node to be removed */ void RemoveChildNode(char key_char) { if (!HasChild(key_char)) { return; } children_.erase(key_char); } /** * TODO(P0): Add implementation * * @brief Set the is_end_ flag to true or false. * * @param is_end Whether this trie node is ending char of a key string */ void SetEndNode(bool is_end) { is_end_ = is_end; } protected: /** Key character of this trie node */ char key_char_; /** whether this node marks the end of a key */ bool is_end_{false}; /** A map of all child nodes of this trie node, which can be accessed by each * child node\u0026#39;s key char. */ std::unordered_map\u0026lt;char, std::unique_ptr\u0026lt;TrieNode\u0026gt;\u0026gt; children_; }; /** * TrieNodeWithValue is a node that marks the ending of a key, and it can * hold a value of any type T. */ template \u0026lt;typename T\u0026gt; class TrieNodeWithValue : public TrieNode { private: /* Value held by this trie node. */ T value_; public: /** * TODO(P0): Add implementation * * @brief Construct a new TrieNodeWithValue object from a TrieNode object and * specify its value. This is used when a non-terminal TrieNode is converted * to terminal TrieNodeWithValue. * * The children_ map of TrieNode should be moved to the new TrieNodeWithValue * object. Since it contains unique pointers, the first parameter is a rvalue * reference. * * You should: * 1) invoke TrieNode\u0026#39;s move constructor to move data from TrieNode to * TrieNodeWithValue. * 2) set value_ member variable of this node to parameter `value`. * 3) set is_end_ to true * * @param trieNode TrieNode whose data is to be moved to TrieNodeWithValue * @param value */ TrieNodeWithValue(TrieNode \u0026amp;\u0026amp;trieNode, T value) : TrieNode(std::move(trieNode)), value_(value) { is_end_ = true; } /** * TODO(P0): Add implementation * * @brief Construct a new TrieNodeWithValue. This is used when a new terminal * node is constructed. * * You should: * 1) Invoke the constructor for TrieNode with the given key_char. * 2) Set value_ for this node. * 3) set is_end_ to true. * * @param key_char Key char of this node * @param value Value of this node */ TrieNodeWithValue(char key_char, T value) : TrieNode(key_char), value_(value) { is_end_ = true; } /** * @brief Destroy the Trie Node With Value object */ ~TrieNodeWithValue() override = default; /** * @brief Get the stored value_. * * @return Value of type T stored in this node */ T GetValue() const { return value_; } }; /** * Trie is a concurrent key-value store. Each key is a string and its * corresponding value can be any type. */ class Trie { private: /* Root node of the trie */ std::unique_ptr\u0026lt;TrieNode\u0026gt; root_; /* Read-write lock for the trie */ ReaderWriterLatch latch_; /** * * @brief Helper function to find the terminal node corresponding to the key * @param key Key used to traverse the trie and find correct node * @return the TrieNode if found, otherwise return nullptr */ std::unique_ptr\u0026lt;TrieNode\u0026gt; *Find(const std::string \u0026amp;key) { if (key.empty()) { return nullptr; } auto curr_node = \u0026amp;root_; for (const char \u0026amp;c : key) { if ((*curr_node)-\u0026gt;HasChild(c)) { curr_node = (*curr_node)-\u0026gt;GetChildNode(c); } else { return nullptr; } } return curr_node; } public: /** * TODO(P0): Add implementation * * @brief Construct a new Trie object. Initialize the root node with \u0026#39;\\0\u0026#39; * character. */ Trie() : root_(std::make_unique\u0026lt;TrieNode\u0026gt;(\u0026#39;\\0\u0026#39;)) {} /** * TODO(P0): Add implementation * * @brief Insert key-value pair into the trie. * * If the key is an empty string, return false immediately. * * If the key already exists, return false. Duplicated keys are not allowed * and you should never overwrite value of an existing key. * * When you reach the ending character of a key: * 1. If TrieNode with this ending character does not exist, create new * TrieNodeWithValue and add it to parent node\u0026#39;s children_ map. * 2. If the terminal node is a TrieNode, then convert it into * TrieNodeWithValue by invoking the appropriate constructor. * 3. If it is already a TrieNodeWithValue, * then insertion fails and returns false. Do not overwrite existing data with * new data. * * You can quickly check whether a TrieNode pointer holds TrieNode or * TrieNodeWithValue by checking the is_end_ flag. If is_end_ == false, then * it points to TrieNode. If is_end_ == true, it points to TrieNodeWithValue. * * @param key Key used to traverse the trie and find the correct node * @param value Value to be inserted * @return True if insertion succeeds, false if the key already exists */ template \u0026lt;typename T\u0026gt; bool Insert(const std::string \u0026amp;key, T value) { if (key.empty()) { return false; } latch_.WLock(); auto curr_node = \u0026amp;root_; for (size_t i = 0; i \u0026lt; key.size() - 1; i++) { curr_node = (*curr_node)-\u0026gt;GetOrCreateChildNode(key[i]); } char terminal_key = key[key.size() - 1]; auto terminal_node = (*curr_node)-\u0026gt;GetChildNode(terminal_key); if (terminal_node == nullptr) { // case 1: create new terminal TrieNode auto terminal_child = std::make_unique\u0026lt;TrieNodeWithValue\u0026lt;T\u0026gt;\u0026gt;(terminal_key, value); (*curr_node)-\u0026gt;InsertChildNode(terminal_key, std::move(terminal_child)); latch_.WUnlock(); return true; } if (!(*terminal_node)-\u0026gt;IsEndNode()) { // case 2 convert TrieNode into TrieNodeWithValue auto converted_node = std::make_unique\u0026lt;TrieNodeWithValue\u0026lt;T\u0026gt;\u0026gt;(std::move(*(*terminal_node)), value); (*curr_node)-\u0026gt;RemoveChildNode(terminal_key); (*curr_node)-\u0026gt;InsertChildNode(terminal_key, std::move(converted_node)); latch_.WUnlock(); return true; } // case 3 duplicate key is not allowed latch_.WUnlock(); return false; } /** * TODO(P0): Add implementation * * @brief Remove key value pair from the trie. * This function should also remove nodes that are no longer part of another * key. If key is empty or not found, return false. * * You should: * 1) Find the terminal node for the given key. * 2) If this terminal node does not have any children, remove it from its * parent\u0026#39;s children_ map. * 3) Recursively remove nodes that have no children and are not terminal node * of another key. * * @param key Key used to traverse the trie and find the correct node * @return True if the key exists and is removed, false otherwise */ bool Remove(const std::string \u0026amp;key) { if (key.empty()) { return false; } latch_.WLock(); auto *node = Find(key); if (node == nullptr || !(*node)-\u0026gt;IsEndNode()) { latch_.WUnlock(); return false; } // logically delete (*node)-\u0026gt;SetEndNode(false); // find lineage from root to terminal node std::vector\u0026lt;std::unique_ptr\u0026lt;TrieNode\u0026gt; *\u0026gt; traverses; // unique_ptr\u0026#39;s pointer,因为unique_ptr不能复制到vector中 auto *curr = \u0026amp;root_; traverses.push_back(curr); for (const char c : key) { curr = (*curr)-\u0026gt;GetChildNode(c); traverses.push_back(curr); } for (size_t i = traverses.size() - 1; i \u0026gt;= 1; i--) { auto child_node = traverses[i]; auto parent_node = traverses[i - 1]; if (!(*child_node)-\u0026gt;IsEndNode() \u0026amp;\u0026amp; !(*child_node)-\u0026gt;HasChildren()) { // remove nodes that has no children and is not terminal node. // 一个非终端节点且没有任何子节点，是需要被物理删除的 (*parent_node)-\u0026gt;RemoveChildNode((*child_node)-\u0026gt;GetKeyChar()); } else { break; } } latch_.WUnlock(); return true; } /** * TODO(P0): Add implementation * * @brief Get the corresponding value of type T given its key. * If key is empty, set success to false. * If key does not exist in trie, set success to false. * If the given type T is not the same as the value type stored in * TrieNodeWithValue (ie. GetValue\u0026lt;int\u0026gt; is called but terminal node holds * std::string), set success to false. * * To check whether the two types are the same, dynamic_cast * the terminal TrieNode to TrieNodeWithValue\u0026lt;T\u0026gt;. If the casted result * is not nullptr, then type T is the correct type. * * @param key Key used to traverse the trie and find the correct node * @param success Whether GetValue is successful or not * @return Value of type T if type matches */ template \u0026lt;typename T\u0026gt; T GetValue(const std::string \u0026amp;key, bool *success) { latch_.RLock(); *success = false; auto terminal_node = Find(key); if (terminal_node == nullptr || !(*terminal_node)-\u0026gt;IsEndNode()) { latch_.RUnlock(); return {}; } auto *node = terminal_node-\u0026gt;get(); auto *casted_node = dynamic_cast\u0026lt;TrieNodeWithValue\u0026lt;T\u0026gt; *\u0026gt;(node); if (casted_node == nullptr) { // type T incompatible latch_.RUnlock(); return {}; } *success = true; latch_.RUnlock(); return casted_node-\u0026gt;GetValue(); } }; } // namespace bustub ","permalink":"https://dueplay.github.io/posts/bustub-project0/","summary":"概览 需要实现一个数据结构为Trie树的kv存储，Trie一种高效的有序树数据结构，用于检索给定键的值。Trie中的每个节点存储一个key的单个字符，并且可以很多字节点，子节点代表key的下一个字符。key的末尾字符的节点(终端节点)会用一个flag标记这是一个key的结束，并存储相应的val。\n下面这个Trie树，有ab-\u0026gt;1,ac-\u0026gt;“val”，两个kv对，注意val可以是任何类型。\n实现 TrieNode TrieNode类代表树中的单个节点，代表一个key中的单个char。一个TrieNode可以有很多子节点，因此用unordered_map来存储每个子节点的字符和子节点指针的映射。此外还需要一个flag来表示该节点是否是一个key的结尾。为了避免内存泄露，采用智能指针。\nTrieNodeWithValue 该类代表一个key的终端节点，它继承了TrieNode，并且增加了自己特有的属性，即需要存储的val.\n可以有两种方式来创建终端节点：\n插入一个key，创建一个新的终端节点。 插入一个key，将非终端节点转换为终端节点，即将TrieNode转为TrieNodeWithValue。因此需要给该类实现一个TrieNodeWithValue(TrieNode \u0026amp;\u0026amp;trieNode, T value)有参构造，用于将已有的非终端节点转为终端节点，这个构造需要去调用TrieNode的移动构造将trieNode的资源转移到终端节点，包括表示的字符和子节点map。 Trie 成员变量有root节点的指针，指向一个根节点(用字符‘\\0’标识)；为了支持并发，还需要一个读写锁 ReaderWriterLatch latch_\n需要实现增删查三个功能\nInsert 插入一个kv对到Trie中，一个key的每个字符都是一个节点，因此需要做的就是从root节点开始，一层一层的插入新节点，如果有该字符的节点了，我们应该重用它。key最后一个字符需要特殊处理，而不是直接在父节点中插入新节点。\n需要判断是否该结尾字符已经在Trie树中，如果是，再判断这个节点是不是一个终端节点，如果是终端节点，则插入失败，因为不支持重复的key，如果不是终端节点，则需要将非终端的TrieNode转为终端节点TrieNodeWithValue。\n如果结尾字符不在Trie树中，创建新的TrieNodeWithValue，然后插入到父节点中，插入完成。\n同时在Insert操作中，应该是上写锁，返回时应该解锁。\nRemove 移除给定key的val，同时需要删除一些没用节点。首先是根据这个key从root开始一层一层遍历，找到该key的终端节点，没有该key对应的终端节点则直接返回false。找到终端节点后，将其flag设为false，表示这不是一个终端节点，逻辑上删除这个kv。下一步我们需要从该节点开始向上递归的删除那些没有任何子节点的非终端节点，因为这些节点肯定是不再会被用到的，既不是一个key的结尾，也不是一个key的中间节点。实现上可以通过从root开始将遍历到该节点的路径保存，然后在路径中从后往前遍历每个节点，判断是否属于这种情况，是则在其父节点的map中移除。\n同样的在Remove操作中，应该是上写锁，返回时应该解锁。\nGetValue 返回指定key对应的val，注意这个val的类型是任意的，所以这是一个函数模板。还是首先从根节点开始一层一层遍历key的每个字符找到最后一个字符所在的节点，然后不是终端节点或者没有该节点，失败直接返回。有这个key所对应的终端节点，那么返回这个终端节点的val。这样就ok了吗？其实不是，由于val是任意类型的，所以还需要判断这个val是不是我们所要的val类型。要检查这两个类型是否相同，将终端 TrieNode 通过dynamic_cast转为 TrieNodeWithValue。 如果转换结果不是 nullptr，则类型 T 是正确的类型。在类型不匹配时，即使有key所对应的终端节点，也应该失败直接返回。只有在类型匹配时，才正确返回其val。\n同样的在GetValue操作中，应该是上读锁，返回时应该解锁。\nReaderWriterLatch 在c++中可以通过std::shared_mutex mutex_很容易得实现一个读写锁。在bustub中已经有一个实现好的读写锁，上写锁mutex_.lock() ,上读锁mutex_.lock_shared(),对应的解锁操作分别是：mutex_.unlock() 和mutex_.unlock_shared()。\n源码 //===----------------------------------------------------------------------===// // // BusTub // // p0_trie.h // // Identification: src/include/primer/p0_trie.h // // Copyright (c) 2015-2022, Carnegie Mellon University Database Group // //===----------------------------------------------------------------------===// #pragma once #include \u0026lt;memory\u0026gt; #include \u0026lt;stdexcept\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;utility\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026#34;common/exception.","title":"bustub project0"},{"content":"文件目录结构 $ tree . ├── add.c ├── div.c ├── head.h ├── main.c ├── mult.c └── sub.c # 指定使用的 cmake 的最低版本，可选，非必须，如果不加可能会有警告 cmake_minimum_required(VERSION 3.0) # 定义工程名称，并可指定工程的版本、工程描述、web主页地址、支持的语言 project(CALC) # 定义工程会生成一个可执行程序，语法add_executable(可执行程序名 源文件名称) add_executable(app add.c div.c main.c mult.c sub.c) # 定义变量，语法: set(VAR VALUE [CACHE TYPE DOCSTRING [FORCE]]).[]里是可选的 # eg.将文件名对应字符串存起来。 # 方式1: 各个源文件之间使用空格间隔 # set(SRC_LIST add.c div.c main.c mult.c sub.c) # 方式2: 各个源文件之间使用分号 ; 间隔 set(SRC_LIST add.c;div.c;main.c;mult.c;sub.c) add_executable(app ${SRC_LIST}) # 指定c++标准 # 使用g++时: $ g++ *.cpp -std=c++11 -o app # C++标准对应有一宏叫做DCMAKE_CXX_STANDARD，在CMake中想要指定C++标准有两种方式： # 在cmakelists.txt中通过 set 命令指定 # 增加-std=c++11 set(CMAKE_CXX_STANDARD 11) # 增加-std=c++14 set(CMAKE_CXX_STANDARD 14) # 增加-std=c++17 set(CMAKE_CXX_STANDARD 17) # 在执行 cmake 命令的时候指定出这个宏的值，-D表示定义宏 #增加-std=c++11 cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=11 #增加-std=c++14 cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=14 #增加-std=c++17 cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=17 # 指定输出的路径，在CMake中指定可执行程序输出的路径，也对应一个宏，叫做EXECUTABLE_OUTPUT_PATH，它的值还是通过set命令进行设置 set(HOME /home/gxj/Linux/Sort) set(EXECUTABLE_OUTPUT_PATH ${HOME}/bin) # 第一行：定义一个变量用于存储一个绝对路径 # 第二行：将拼接好的路径值设置给EXECUTABLE_OUTPUT_PATH宏 # 如果这个路径中的子目录不存在，会自动生成，无需自己手动创建 # 使用相对路径时，./表示生成的makefile所在目录 # 搜索文件 # 如果一个项目里边的源文件很多，在编写CMakeLists.txt文件的时候不可能将项目目录的各个文件一一罗列出来，这样太麻烦也不现实。所以，在CMake中为我们提供了搜索文件的命令，可以使用aux_source_directory命令或者file命令。 # 使用aux_source_directory 命令可以查找某个路径下的所有源文件，命令格式为： aux_source_directory(\u0026lt; dir \u0026gt; \u0026lt; variable \u0026gt;) dir：要搜索的目录 variable：将从dir目录下搜索到的源文件列表存储到该变量中 # 搜索 src 目录下的源文件 aux_source_directory(${CMAKE_CURRENT_SOURCE_DIR}/src SRC_LIST) add_executable(app ${SRC_LIST}) # 使用file 命令 (当然，除了搜索以外通过 file 还可以做其他事情) file(GLOB/GLOB_RECURSE 变量名 要搜索的文件路径和文件类型) GLOB: 将指定目录下搜索到的满足条件的所有文件名生成一个列表，并将其存储到变量中。 GLOB_RECURSE：递归搜索指定目录，将搜索到的满足条件的文件名生成一个列表，并将其存储到变量中。 搜索当前目录的src目录下所有的源文件，并存储到变量中 file(GLOB MAIN_SRC ${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp) file(GLOB MAIN_HEAD ${CMAKE_CURRENT_SOURCE_DIR}/include/*.h) CMAKE_CURRENT_SOURCE_DIR 宏表示当前访问的 CMakeLists.txt 文件所在的路径。 要搜索的文件路径和类型可加双引号，也可不加: file(GLOB MAIN_HEAD \u0026#34;${CMAKE_CURRENT_SOURCE_DIR}/src/*.h\u0026#34;) # 包含头文件 # 在编译项目源文件的时候，很多时候都需要将源文件对应的头文件路径指定出来，这样才能保证在编译过程中编译器能够找到这些头文件，并顺利通过编译。在CMake中设置要包含的目录也很简单，通过include_directories命令 include_directories(headpath) # 指定就是头文件的路径为项目根目录下面的include include_directories(${PROJECT_SOURCE_DIR}/include) PROJECT_SOURCE_DIR宏对应的值就是我们在使用cmake命令时，后面紧跟的目录，一般是工程的根目录。 # 制作动态库或静态库，源代码并不需要将他们编译生成可执行程序，而是生成一些静态库或动态库提供给第三方使用，下面来是在cmake中生成这两类库文件的方法。 # 在cmake中，如果要制作静态库，需要使用的命令如下：静态库名字分为三部分：lib+库名字+.a，此处只需要指定出库的名字就可以了 add_library(库名称 STATIC 源文件1 [源文件2] ...) # eg include_directories(${PROJECT_SOURCE_DIR}/include) file(GLOB SRC_LIST \u0026#34;${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp\u0026#34;) add_library(calc STATIC ${SRC_LIST}) # 要制作动态库，需要使用的命令如下，动态库名字分为三部分：lib+库名字+.so，此处只需要指定出库的名字就可以了，另外两部分在生成该文件的时候会自动填充。 add_library(库名称 SHARED 源文件1 [源文件2] ...) add_library(calc SHARED ${SRC_LIST}) # 指定库输出的路径 # 方式1 - 适用于动态库 对于生成的库文件来说和可执行程序一样都可以指定输出路径。由于在Linux下生成的动态库默认是有执行权限的，所以可以按照生成可执行程序的方式去指定它生成的目录： # 设置动态库生成路径，其实就是通过set命令给EXECUTABLE_OUTPUT_PATH宏设置了一个路径，这个路径就是可执行文件生成的路径 set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib) add_library(calc SHARED ${SRC_LIST}) # 方式2 - 都适用 由于在Linux下生成的静态库默认不具有可执行权限，所以在指定静态库生成的路径的时候就不能使用EXECUTABLE_OUTPUT_PATH宏了，而应该使用LIBRARY_OUTPUT_PATH，这个宏对应静态库文件和动态库文件都适用。 # 设置动态库/静态库生成路径 set(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib) # 生成动态库 #add_library(calc SHARED ${SRC_LIST}) # 生成静态库 add_library(calc STATIC ${SRC_LIST}) # 包含库文件 # 链接静态库的命令如下：参数1：指定出要链接的静态库的名字，可以是全名 libxxx.a，也可以是掐头（lib）去尾（.a）之后的名字 xxx。参数2-N：要链接的其它静态库的名字 link_libraries(\u0026lt;static lib\u0026gt; [\u0026lt;static lib\u0026gt;...]) 如果该静态库不是系统提供的（自己制作或者使用第三方提供的静态库）可能出现静态库找不到的情况，此时可以将静态库的路径也指定出来： link_directories(\u0026lt;lib path\u0026gt;) # 包含静态库路径 link_directories(${PROJECT_SOURCE_DIR}/lib) # 链接静态库 link_libraries(calc) # 链接动态库，使用 target_link_libraries 命令就可以链接动态库，也可以链接静态库文件。 target_link_libraries( \u0026lt;target\u0026gt; \u0026lt;PRIVATE|PUBLIC|INTERFACE\u0026gt; \u0026lt;item\u0026gt;... [\u0026lt;PRIVATE|PUBLIC|INTERFACE\u0026gt; \u0026lt;item\u0026gt;...]...) target：指定要加载动态库的文件的名字该文件可能是一个源文件,or动态库文件or可执行文件 PRIVATE|PUBLIC|INTERFACE：动态库的访问权限，默认为PUBLIC 如果各个动态库之间没有依赖关系，无需做任何设置，三者没有没有区别，一般无需指定，使用默认的 PUBLIC 即可。 PUBLIC：在public后面的库会被Link到前面的target中，并且里面的符号也会被导出，提供给第三方使用。 PRIVATE：在private后面的库仅被link到前面的target中，并且终结掉，第三方不能感知你调了啥库 INTERFACE：在interface后面引入的库不会被链接到前面的target中，只会导出符号。 动态库的链接和静态库是完全不同的： 静态库会在生成可执行程序的链接阶段被打包到可执行程序中，所以可执行程序启动，静态库就被加载到内存中了。 动态库在生成可执行程序的链接阶段不会被打包到可执行程序中，当可执行程序被启动并且调用了动态库中的函数的时候，动态库才会被加载到内存 因此，在cmake中指定要链接的动态库的时候，应该将命令写到生成了可执行文件之后： # 添加并指定最终生成的可执行程序名 add_executable(app ${SRC_LIST}) # 指定可执行程序要链接的动态库名字 target_link_libraries(app pthread) app: 对应的是最终生成的可执行程序的名字 pthread：这是可执行程序要加载的动态库，这个库是系统提供的线程库，全名为libpthread.so，在指定的时候一般会掐头（lib）去尾（.so）。 # 链接第三方动态库，假设在测试文件main.cpp中既使用了自己制作的动态库libcalc.so又使用了系统提供的线程库，此时CMakeLists.txt文件可以这样写：、 cmake_minimum_required(VERSION 3.0) project(TEST) file(GLOB SRC_LIST ${CMAKE_CURRENT_SOURCE_DIR}/*.cpp) include_directories(${PROJECT_SOURCE_DIR}/include) add_executable(app ${SRC_LIST}) target_link_libraries(app pthread calc) pthread、calc都是可执行程序app要链接的动态库的名字。当可执行程序app生成之后并执行该文件，会提示有如下错误信息： error while loading shared libraries: libcalc.so: cannot open shared object file: No such file or directory 这是因为可执行程序启动之后，去加载calc这个动态库，但是不知道这个动态库被放到了什么位置，所以就加载失败了，在 CMake 中可以在生成可执行程序之前，通过命令指定出要链接的动态库的位置，指定静态库位置使用的也是这个命令： link_directories(path) 修改之后的CMakeLists.txt文件应该是这样的： cmake_minimum_required(VERSION 3.0) project(TEST) file(GLOB SRC_LIST ${CMAKE_CURRENT_SOURCE_DIR}/*.cpp) # 指定源文件或者动态库对应的头文件路径 include_directories(${PROJECT_SOURCE_DIR}/include) # 指定要链接的动态库的路径 link_directories(${PROJECT_SOURCE_DIR}/lib) # 添加并生成一个可执行程序 add_executable(app ${SRC_LIST}) # 指定要链接的动态库 target_link_libraries(app pthread calc) # 日志，在CMake中可以用message显示一条消息 message([STATUS|WARNING|AUTHOR_WARNING|FATAL_ERROR|SEND_ERROR] \u0026#34;message to display\u0026#34; ...) (无) ：重要消息 STATUS ：非重要消息 WARNING：CMake 警告, 会继续执行 AUTHOR_WARNING：CMake 警告 (dev), 会继续执行 SEND_ERROR：CMake 错误, 继续执行，但是会跳过生成的步骤 FATAL_ERROR：CMake 错误, 终止所有处理过程 CMake的命令行工具会在stdout上显示STATUS消息，在stderr上显示其他所有消息。CMake的GUI会在它的log区域显示所有消息。 CMake警告和错误消息的文本显示使用的是一种简单的标记语言。文本没有缩进，超过长度的行会回卷，段落之间以新行做为分隔符。 # 输出一般日志信息 message(STATUS \u0026#34;source path: ${PROJECT_SOURCE_DIR}\u0026#34;) # 输出警告信息 message(WARNING \u0026#34;source path: ${PROJECT_SOURCE_DIR}\u0026#34;) # 输出错误信息 message(FATAL_ERROR \u0026#34;source path: ${PROJECT_SOURCE_DIR}\u0026#34;) # 变量操作 # 追加 -使用set拼接 如果使用set进行字符串拼接，对应的命令格式如下： set(变量名1 ${变量名1} ${变量名2} ...) 将从第二个参数开始往后所有的字符串进行拼接，最后将结果存储到第一个参数中，如果第一个参数中原来有数据会对原数据就行覆盖。 # eg set(TEMP \u0026#34;hello,world\u0026#34;) file(GLOB SRC_1 ${PROJECT_SOURCE_DIR}/src1/*.cpp) file(GLOB SRC_2 ${PROJECT_SOURCE_DIR}/src2/*.cpp) # 追加(拼接),将src1，src2，temp拼接为一个str存到src1中 set(SRC_1 ${SRC_1} ${SRC_2} ${TEMP}) message(STATUS \u0026#34;message: ${SRC_1}\u0026#34;) # 使用list拼接 list(APPEND \u0026lt;list\u0026gt; [\u0026lt;element\u0026gt; ...]) list命令的功能比set要强大，字符串拼接只是它的其中一个功能，所以需要在它第一个参数的位置指定出我们要做的操作，APPEND表示进行数据追加，后边的参数和set就一样了。 # 追加(拼接),APPEND后面同set的参数一致 list(APPEND SRC_1 ${SRC_1} ${SRC_2} ${TEMP}) message(STATUS \u0026#34;message: ${SRC_1}\u0026#34;) 使用set命令可以创建一个list。一个在list内部是一个由分号;分割的一组字符串。例如，set(var a b c d e)命令将会创建一个list:a;b;c;d;e，但是最终打印变量值的时候得到的是abcde。 set(tmp1 a;b;c;d;e) set(tmp2 a b c d e) message(${tmp1}) message(${tmp2}) 输出的结果: abcde abcde # 字符串移除 在当前这么目录有五个源文件，其中main.cpp是一个测试文件。如果我们想要把计算器相关的源文件生成一个动态库给别人使用，那么只需要add.cpp、div.cp、mult.cpp、sub.cpp这四个源文件就可以了。此时，就需要将main.cpp从搜索到的数据中剔除出去，想要实现这个功能，也可以使用list list(REMOVE_ITEM \u0026lt;list\u0026gt; \u0026lt;value\u0026gt; [\u0026lt;value\u0026gt; ...]) 通过上面的命令原型可以看到删除和追加数据类似，只不过是第一个参数变成了REMOVE_ITEM。 cmake_minimum_required(VERSION 3.0) project(TEST) set(TEMP \u0026#34;hello,world\u0026#34;) file(GLOB SRC_1 ${PROJECT_SOURCE_DIR}/*.cpp) # 移除前日志 message(STATUS \u0026#34;message: ${SRC_1}\u0026#34;) # 移除 main.cpp list(REMOVE_ITEM SRC_1 ${PROJECT_SOURCE_DIR}/main.cpp) # 移除后日志 message(STATUS \u0026#34;message: ${SRC_1}\u0026#34;) 可以看到，在第8行把将要移除的文件的名字指定给list就可以了。但是一定要注意通过 file 命令搜索源文件的时候得到的是文件的绝对路径（在list中每个文件对应的路径都是一个item，并且都是绝对路径），那么在移除的时候也要将该文件的绝对路径指定出来才可以，否是移除操作不会成功。 关于list命令还有其它功能，但是并不常用，在此就不一一进行举例介绍了。 获取 list 的长度。 list(LENGTH \u0026lt;list\u0026gt; \u0026lt;output variable\u0026gt;) LENGTH：子命令LENGTH用于读取列表长度 \u0026lt;list\u0026gt;：当前操作的列表 \u0026lt;output variable\u0026gt;：新创建的变量，用于存储列表的长度。 读取列表中指定索引的的元素，可以指定多个索引 list(GET \u0026lt;list\u0026gt; \u0026lt;element index\u0026gt; [\u0026lt;element index\u0026gt; ...] \u0026lt;output variable\u0026gt;) \u0026lt;list\u0026gt;：当前操作的列表 \u0026lt;element index\u0026gt;：列表元素的索引 从0开始编号，索引0的元素为列表中的第一个元素； 索引也可以是负数，-1表示列表的最后一个元素，-2表示列表倒数第二个元素，以此类推 当索引（不管是正还是负）超过列表的长度，运行会报错 \u0026lt;output variable\u0026gt;：新创建的变量，存储指定索引元素的返回结果，也是一个列表。 将列表中的元素用连接符（字符串）连接起来组成一个字符串 list (JOIN \u0026lt;list\u0026gt; \u0026lt;glue\u0026gt; \u0026lt;output variable\u0026gt;) \u0026lt;list\u0026gt;：当前操作的列表 \u0026lt;glue\u0026gt;：指定的连接符（字符串） \u0026lt;output variable\u0026gt;：新创建的变量，存储返回的字符串 查找列表是否存在指定的元素，若果未找到，返回-1 list(FIND \u0026lt;list\u0026gt; \u0026lt;value\u0026gt; \u0026lt;output variable\u0026gt;) \u0026lt;list\u0026gt;：当前操作的列表 \u0026lt;value\u0026gt;：需要再列表中搜索的元素 \u0026lt;output variable\u0026gt;：新创建的变量 如果列表\u0026lt;list\u0026gt;中存在\u0026lt;value\u0026gt;，那么返回\u0026lt;value\u0026gt;在列表中的索引 如果未找到则返回-1。 将元素追加到列表中 list (APPEND \u0026lt;list\u0026gt; [\u0026lt;element\u0026gt; ...]) 在list中指定的位置插入若干元素 list(INSERT \u0026lt;list\u0026gt; \u0026lt;element_index\u0026gt; \u0026lt;element\u0026gt; [\u0026lt;element\u0026gt; ...]) 将元素插入到列表的0索引位置 list (PREPEND \u0026lt;list\u0026gt; [\u0026lt;element\u0026gt; ...]) 将列表中最后元素移除 list (POP_BACK \u0026lt;list\u0026gt; [\u0026lt;out-var\u0026gt;...]) 将列表中第一个元素移除 list (POP_FRONT \u0026lt;list\u0026gt; [\u0026lt;out-var\u0026gt;...]) 将指定的元素从列表中移除 list (REMOVE_ITEM \u0026lt;list\u0026gt; \u0026lt;value\u0026gt; [\u0026lt;value\u0026gt; ...]) 将指定索引的元素从列表中移除 list (REMOVE_AT \u0026lt;list\u0026gt; \u0026lt;index\u0026gt; [\u0026lt;index\u0026gt; ...]) 移除列表中的重复元素 list (REMOVE_DUPLICATES \u0026lt;list\u0026gt;) 列表翻转 list(REVERSE \u0026lt;list\u0026gt;) 列表排序 list (SORT \u0026lt;list\u0026gt; [COMPARE \u0026lt;compare\u0026gt;] [CASE \u0026lt;case\u0026gt;] [ORDER \u0026lt;order\u0026gt;]) COMPARE：指定排序方法。有如下几种值可选： STRING:按照字母顺序进行排序，为默认的排序方法 FILE_BASENAME：如果是一系列路径名，会使用basename进行排序 NATURAL：使用自然数顺序排序 CASE：指明是否大小写敏感。有如下几种值可选： SENSITIVE: 按照大小写敏感的方式进行排序，为默认值 INSENSITIVE：按照大小写不敏感方式进行排序 ORDER：指明排序的顺序。有如下几种值可选： ASCENDING:按照升序排列，为默认值 DESCENDING：按照降序排列 # 宏定义 #ifdef DEBUG printf(\u0026#34;我是一个程序猿, 我不会爬树...\\n\u0026#34;); #endif 为了让测试更灵活，我们可以不在代码中定义所需定义的宏，而是在测试的时候去把它定义出来，其中一种方式就是在gcc/g++命令中去指定 $ gcc test.c -DDEBUG -o app 在gcc/g++命令中通过参数 -D指定出要定义的宏的名字，这样就相当于在代码中定义了一个宏，其名字为DEBUG。 在CMake中我们也可以做类似的事情，对应的命令叫做add_definitions: add_definitions(-D宏名称) # 自定义 DEBUG 宏 add_definitions(-DDEBUG) add_executable(app ./test.c) # cmake预定义宏 宏\t功能 PROJECT_SOURCE_DIR\t使用cmake命令后紧跟的目录，一般是工程的根目录 PROJECT_BINARY_DIR\t执行cmake命令的目录 CMAKE_CURRENT_SOURCE_DIR\t当前处理的CMakeLists.txt所在的路径 CMAKE_CURRENT_BINARY_DIR\ttarget 编译目录 EXECUTABLE_OUTPUT_PATH\t重新定义目标二进制可执行文件的存放位置 LIBRARY_OUTPUT_PATH\t重新定义目标链接库文件的存放位置 PROJECT_NAME\t返回通过PROJECT指令定义的项目名称 CMAKE_BINARY_DIR\t项目实际构建路径，假设在build目录进行的构建，那么得到的就是这个目录的路径 执行cmake # 在CMakeLists.txt所在目录执行 $ cmake . # 在build目录执行 $ cmake .. CMake 3.11 FetchContent模块 FetchContent 是 CMake 3.11 及以上版本中引入的一个功能，它允许你在构建时自动从外部获取依赖项，而不需要手动下载或预先安装它们。\n编写cmake： cmake_minimum_required(VERSION 3.14) # 确保使用了足够新的 CMake 版本 project(MyProject VERSION 1.0) # 包含 FetchContent 模块 include(FetchContent) # 声明 GoogleTest 作为外部依赖项 FetchContent_Declare( googletest GIT_REPOSITORY https://github.com/google/googletest.git GIT_TAG release-1.10.0 # GIT_TAG 参数可以是分支名或标签，不是必须的，但它是推荐的做法，不指定下载默认分支 ) # 使外部依赖项（GoogleTest）可用 FetchContent_MakeAvailable(googletest) # 添加你的项目文件（替换为你的源文件） add_executable(my_project main.cpp) # 定义一个测试目标 enable_testing() # 添加测试可执行文件 add_executable( my_test tests/test1.cpp tests/test2.cpp ) # 链接 GoogleTest 到测试可执行文件 target_link_libraries( my_test gtest_main ) # 包含 GoogleTest 的测试 include(GoogleTest) gtest_discover_tests(my_test) 在这个示例中：\n使用 FetchContent_Declare 声明了 GoogleTest 作为一个外部依赖项，指定了其 Git 仓库地址和要使用的标签（在这个例子中是 release-1.10.0）。 通过 FetchContent_MakeAvailable 自动下载（如果需要的话）、配置和构建 GoogleTest。 创建了两个可执行文件目标：一个是主项目 my_project，另一个是测试项目 my_test。 my_test 测试可执行文件链接了 GoogleTest，并使用 gtest_discover_tests 自动发现和注册 GoogleTest 测试。 第二步：编写测试 在 tests 目录下创建测试文件（例如，test1.cpp 和 test2.cpp），并使用 GoogleTest 编写测试。\n第三步：构建和运行测试 创建一个构建目录并进入：\nmkdir build \u0026amp;\u0026amp; cd build 使用 CMake 配置项目并构建：\ncmake --build . 运行测试：\nctest 使用catch2 v3.x版本的测试cmake cmake_minimum_required(VERSION 3.14) # 确保使用的是 FetchContent 可用的 CMake 版本 project(MyProject VERSION 1.0) include_directories(${PROJECT_SOURCE_DIR}/include) # 包含 FetchContent 模块 include(FetchContent) # 使用 FetchContent_Declare 声明 Catch2 作为外部依赖项 FetchContent_Declare( Catch2 GIT_REPOSITORY https://github.com/catchorg/Catch2.git GIT_TAG v3.3.0 # or a later release ) # 使 Catch2 可用 FetchContent_MakeAvailable(Catch2) # 添加你的项目文件（示例） add_executable(my_project src/main.cpp src/sub.cpp) # 如果你有测试代码，可以像这样设置 enable_testing() # 启用测试 # 添加测试可执行文件 add_executable( my_test test/test1.cpp src/sub.cpp # 添加其他测试文件 ) # 链接 Catch2 到测试可执行文件 target_link_libraries(my_test PRIVATE Catch2::Catch2WithMain) # 为 Catch2 配置测试发现 LIST(APPEND CMAKE_MODULE_PATH ${catch2_SOURCE_DIR}/extras) include(CTest) include(Catch) CATCH_DISCOVER_TESTS(my_test) ","permalink":"https://dueplay.github.io/posts/cmake/","summary":"文件目录结构 $ tree . ├── add.c ├── div.c ├── head.h ├── main.c ├── mult.c └── sub.c # 指定使用的 cmake 的最低版本，可选，非必须，如果不加可能会有警告 cmake_minimum_required(VERSION 3.0) # 定义工程名称，并可指定工程的版本、工程描述、web主页地址、支持的语言 project(CALC) # 定义工程会生成一个可执行程序，语法add_executable(可执行程序名 源文件名称) add_executable(app add.c div.c main.c mult.c sub.c) # 定义变量，语法: set(VAR VALUE [CACHE TYPE DOCSTRING [FORCE]]).[]里是可选的 # eg.将文件名对应字符串存起来。 # 方式1: 各个源文件之间使用空格间隔 # set(SRC_LIST add.c div.c main.c mult.c sub.c) # 方式2: 各个源文件之间使用分号 ; 间隔 set(SRC_LIST add.c;div.c;main.c;mult.c;sub.c) add_executable(app ${SRC_LIST}) # 指定c++标准 # 使用g++时: $ g++ *.cpp -std=c++11 -o app # C++标准对应有一宏叫做DCMAKE_CXX_STANDARD，在CMake中想要指定C++标准有两种方式： # 在cmakelists.","title":"cmake Tutorial"},{"content":"为什么使用Protocol Buffer? 想象一下我们需要序列化/反序列化一个数据结构，有几种可行的方法：\n将原始内存数据结构保存为二进制形式。 但这是一种脆弱的方法，因为它要求读取端必须遵守完全相同的内存布局，并禁止数据格式的扩展。 编写我们自己的编码策略，例如以冒号为分隔的字符串“12:3:-23:67”，这需要我们编写编码和解析代码，这也带来了运行时开销。 将数据序列化为 XML 形式。 这是广泛使用的人类可读格式。 然而，XML 由于冗长而需要大量的存储空间。 Protocol Buffer ：灵活、高效、自动化的解决方案 定义Message syntax = \u0026#34;proto3\u0026#34;; // 版本 // 相当于c++中的namespace package tutorial; // 相当于c++中的class/struct message Person { // optional 修饰符表明该字段可能被设置，也可能不被设置。当从未设置的字段中检索值时，return系统默认值，整数为0，字符串为空等。 optional string name = 1; optional int32 id = 2; optional string email =3; // 对于枚举类型，默认值是枚举类型中定义的第一个值 enum PhoneType { MOBILE = 0; HOME = 1; WORK = 2; } message PhoneNumber { optional string number = 1; optional PhoneType type = 2; } // repeated 修饰符相当于数组 repeated PhoneNumber phones = 4; } message AddressBook { repeated Person people = 1; } protobuf buffer message格式定义非常接近 C/C++ 中的类/结构定义。 有相当多的原始数据类型可用，例如int32、string，并且我们可以嵌套自定义数据类型，例如嵌套在PhoneNumber中的PhoneType，以及嵌套在AddressBook中的Person。\n编译Message 安装protocol buffer.在Ubuntu 22.04 LTS,通过下面方式安装\n$ sudo apt install -y protobuf-compiler 检查它的版本是否是最新的\n$ protoc --version libprotoc 3.12.4 现在我们可以将 protobuf message 格式编译成 cpp 文件。 让编译器为我们生成代码。\n$ ls addressbook.proto $ protoc --experimental_allow_proto3_optional --cpp_out=. addressbook.proto // 编译到当前目录 $ ls addressbook.pb.cc addressbook.pb.h addressbook.proto 编译器为我们生成了addressbook.ph.h和addressbook.ph.cc。 代码里包含很多我们上面刚刚定义的消息格式的 getter 和 setter 函数。\n常用的message方法 在所有版本的 protobuf 中都有一些常用的方法。\nbool IsInitialized() const: checks if all the required fields have been set. string DebugString() const: returns a human-readable representation of the message, particularly useful for debugging. void CopyFrom(const Person\u0026amp; from): overwrites the message with the given message’s values. void Clear(): clears all the elements back to the empty state. bool SerializeToString(string* output) const: serializes the message and stores the bytes in the given string. Note that the bytes are binary, not text; we only use the string class as a convenient container. bool ParseFromString(const string\u0026amp; data): parses a message from the given string. bool SerializeToOstream(ostream* output) const: writes the message to the given C++ ostream. bool ParseFromIstream(istream* input): parses a message from the given C++ istream. 例子 一个简单的程序，将新的地址信息附加到数据文件中。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026#34;addressbook.pb.h\u0026#34; void PromptForAddress(tutorial::Person *person) { std::cout \u0026lt;\u0026lt; \u0026#34;Enter person ID number: \u0026#34;; int id; std::cin \u0026gt;\u0026gt; id; person-\u0026gt;set_id(id); std::cin.ignore(256, \u0026#39;\\n\u0026#39;); std::cout \u0026lt;\u0026lt; \u0026#34;Enter name: \u0026#34;; getline(std::cin, *person-\u0026gt;mutable_name()); std::cout \u0026lt;\u0026lt; \u0026#34;Enter email address (blank for none): \u0026#34;; std::string email; getline(std::cin, email); if (!email.empty()) { person-\u0026gt;set_email(email); } while(true) { std::cout \u0026lt;\u0026lt; \u0026#34;Enter a phone number (or leave blank to finish): \u0026#34;; std::string number; getline(std::cin, number); if (number.empty()) { break; } tutorial::Person::PhoneNumber *phone_number = person-\u0026gt;add_phones(); phone_number-\u0026gt;set_number(number); std::cout \u0026lt;\u0026lt; \u0026#34;Is this a mobile, home, or work phone? \u0026#34;; std::string type; getline(std::cin, type); if (type == \u0026#34;mobile\u0026#34;) { phone_number-\u0026gt;set_type(tutorial::Person::MOBILE); } else if (type == \u0026#34;home\u0026#34;) { phone_number-\u0026gt;set_type(tutorial::Person::HOME); } else if (type == \u0026#34;work\u0026#34;) { phone_number-\u0026gt;set_type(tutorial::Person::WORK); } else { std::cout \u0026lt;\u0026lt; \u0026#34;Unknown phone type. Using default.\u0026#34; \u0026lt;\u0026lt; std::endl; } } } // 从文件中读取整个地址簿，根据用户输入添加一个人，然后将其写回到同一文件中。 int main(int argc, char* argv[]) { // 验证我们链接的库的版本是否与我们编译的header的版本兼容。 GOOGLE_PROTOBUF_VERIFY_VERSION; if (argc != 2) { std::cerr \u0026lt;\u0026lt; \u0026#34;Usage : \u0026#34; \u0026lt;\u0026lt; argv[0] \u0026lt;\u0026lt; \u0026#34; ADDRESSBOOK_FILE\u0026#34; \u0026lt;\u0026lt; std::endl; return -1; } tutorial::AddressBook address_book; std::fstream ifs(argv[1], std::ios::in | std::ios::binary); if (!ifs) { std::cout \u0026lt;\u0026lt; argv[1] \u0026lt;\u0026lt; \u0026#34;: File not found. Creating a new file.\u0026#34; \u0026lt;\u0026lt; std::endl; } else if (!address_book.ParseFromIstream(\u0026amp;ifs)) { std::cerr \u0026lt;\u0026lt; \u0026#34;Failed to parse address book.\u0026#34; \u0026lt;\u0026lt; std::endl; return -1; } // Add an address. PromptForAddress(address_book.add_people()); // Write the new address book back to disk. std::fstream ofs(argv[1], std::ios::out | std::ios::binary | std::ios::trunc); if (!address_book.SerializeToOstream(\u0026amp;ofs)) { std::cerr \u0026lt;\u0026lt; \u0026#34;Failed to serialize address book.\u0026#34; \u0026lt;\u0026lt; std::endl; return -1; } // 可选: 删除 libprotobuf 分配的所有全局对象。 google::protobuf::ShutdownProtobufLibrary(); return 0; } 读二进制文件中的消息\n读上面写的数据文件并展示里面包含的所有信息.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026#34;addressbook.pb.h\u0026#34; void ListPeople(tutorial::AddressBook\u0026amp; address_book) { for (int i = 0; i \u0026lt; address_book.people_size(); i++) { const tutorial::Person\u0026amp; person = address_book.people(i); std::cout \u0026lt;\u0026lt; \u0026#34;Person ID: \u0026#34; \u0026lt;\u0026lt; person.id() \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; Name: \u0026#34; \u0026lt;\u0026lt; person.name() \u0026lt;\u0026lt; std::endl; if (person.has_email()) { std::cout \u0026lt;\u0026lt; \u0026#34; email address: \u0026#34; \u0026lt;\u0026lt; person.email() \u0026lt;\u0026lt; std::endl; } for (int j = 0; j \u0026lt; person.phones_size(); j++) { const tutorial::Person::PhoneNumber\u0026amp; phone_number = person.phones(j); switch (phone_number.type()) { case tutorial::Person::MOBILE: std::cout \u0026lt;\u0026lt; \u0026#34; Mobile phone #: \u0026#34;; break; case tutorial::Person::HOME: std::cout \u0026lt;\u0026lt; \u0026#34; Home phone #: \u0026#34;; break; case tutorial::Person::WORK: std::cout \u0026lt;\u0026lt; \u0026#34; Work phone #: \u0026#34;; break; } std::cout \u0026lt;\u0026lt; phone_number.number() \u0026lt;\u0026lt; std::endl; } } } // 从文件中读取整个地址簿并打印其中的所有信息。 int main(int argc, char* argv[]) { // 验证我们链接的库的版本是否与我们编译的header的版本兼容。 GOOGLE_PROTOBUF_VERIFY_VERSION; if (argc != 2) { std::cerr \u0026lt;\u0026lt; \u0026#34;Usage : \u0026#34; \u0026lt;\u0026lt; argv[0] \u0026lt;\u0026lt; \u0026#34; ADDRESSBOOK_FILE\u0026#34; \u0026lt;\u0026lt; std::endl; return -1; } tutorial::AddressBook address_book; std::fstream ifs(argv[1], std::ios::in | std::ios::binary); if (!address_book.ParseFromIstream(\u0026amp;ifs)) { std::cerr \u0026lt;\u0026lt; \u0026#34;Failed to parse address book.\u0026#34; \u0026lt;\u0026lt; std::endl; return -1; } ListPeople(address_book); // 可选: 删除 libprotobuf 分配的所有全局对象。 google::protobuf::ShutdownProtobufLibrary(); return 0; } 编译运行 $ g++ -std=c++14 writer.cpp addressbook.pb.cc -o writer -lpthread -lprotobuf $ g++ -std=c++14 reader.cpp addressbook.pb.cc -o reader -lpthread -lprotobuf ","permalink":"https://dueplay.github.io/posts/protocol-buffer/","summary":"为什么使用Protocol Buffer? 想象一下我们需要序列化/反序列化一个数据结构，有几种可行的方法：\n将原始内存数据结构保存为二进制形式。 但这是一种脆弱的方法，因为它要求读取端必须遵守完全相同的内存布局，并禁止数据格式的扩展。 编写我们自己的编码策略，例如以冒号为分隔的字符串“12:3:-23:67”，这需要我们编写编码和解析代码，这也带来了运行时开销。 将数据序列化为 XML 形式。 这是广泛使用的人类可读格式。 然而，XML 由于冗长而需要大量的存储空间。 Protocol Buffer ：灵活、高效、自动化的解决方案 定义Message syntax = \u0026#34;proto3\u0026#34;; // 版本 // 相当于c++中的namespace package tutorial; // 相当于c++中的class/struct message Person { // optional 修饰符表明该字段可能被设置，也可能不被设置。当从未设置的字段中检索值时，return系统默认值，整数为0，字符串为空等。 optional string name = 1; optional int32 id = 2; optional string email =3; // 对于枚举类型，默认值是枚举类型中定义的第一个值 enum PhoneType { MOBILE = 0; HOME = 1; WORK = 2; } message PhoneNumber { optional string number = 1; optional PhoneType type = 2; } // repeated 修饰符相当于数组 repeated PhoneNumber phones = 4; } message AddressBook { repeated Person people = 1; } protobuf buffer message格式定义非常接近 C/C++ 中的类/结构定义。 有相当多的原始数据类型可用，例如int32、string，并且我们可以嵌套自定义数据类型，例如嵌套在PhoneNumber中的PhoneType，以及嵌套在AddressBook中的Person。","title":"Protocol Buffer的使用"},{"content":"知识点中转站！\n分布式 Raft：\n论文 翻译 Paxos：\nOpenACID Blog 最终一致性：\nDDIA 线性一致性：\nDDIA PingCAP：Raft与线性一致性 线性一致性与可串行化 CAP 定理：\nCAP定理没有帮助 顺序：\nDDIA 全序广播：\nDDIA 2PC：\nDDIA 3PC：\nDDIA ","permalink":"https://dueplay.github.io/posts/database-and-distributed-system-tags/","summary":"知识点中转站！\n分布式 Raft：\n论文 翻译 Paxos：\nOpenACID Blog 最终一致性：\nDDIA 线性一致性：\nDDIA PingCAP：Raft与线性一致性 线性一致性与可串行化 CAP 定理：\nCAP定理没有帮助 顺序：\nDDIA 全序广播：\nDDIA 2PC：\nDDIA 3PC：\nDDIA ","title":"Database and Distributed System TAGS"},{"content":"安装 ubuntu系统默认的shell是bash，可以使用echo $SHELL命令来查看当前使用的shell，zsh是bash的一个替代品，它的功能更加强大和丰富，可以使用cat /etc/shells来查看支持的shell\n如果结果中没有zsh的话就需要使用下面的命令来安装一下：\nsudo apt install zsh -y 安装字体 这里安装powerlevel10k主题推荐使用的MesloLGS-Nerd字体。\n一般在初次安装配置主题的时候会默认提示安装，但是如果没有正常安装的话也可以使用下面的内容来手动安装一下： MesloLGS字体ttf文件下载地址：\nwget https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS%20NF%20Regular.ttf \u0026amp;\u0026amp; wget https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS%20NF%20Bold.ttf \u0026amp;\u0026amp; wget https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS%20NF%20Italic.ttf \u0026amp;\u0026amp; wget https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS%20NF%20Bold%20Italic.ttf 安装完成之后在系统设置或者各个软件比如终端或者VSCode上把字体设置为MesloLGS NF就可以了。\n# 将下载的字体拷贝至truetype sudo cp ttf/*.ttf /usr/share/fonts/truetype/ # 安装fontconfig sudo apt install fontconfig # 刷新字体缓存 fc-cache -fv 安装Oh-My-Zsh sh -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026#34; 慢或者失败的小伙伴可以换成国内源:\nwget https://gitee.com/mirrors/oh-my-zsh/raw/master/tools/install.sh 下载之后给install.sh添加执行权限：\nchmod +x install.sh 然后还需要修改一下安装脚本中的远程仓库地址：\n打开install.sh文件，找到以下部分：\n# Default settings ZSH=${ZSH:-~/.oh-my-zsh} REPO=${REPO:-ohmyzsh/ohmyzsh} REMOTE=${REMOTE:-https://github.com/${REPO}.git} BRANCH=${BRANCH:-master} 将中间两行修改为下面这样，使用gitee镜像：\nREPO=${REPO:-mirrors/ohmyzsh} REMOTE=${REMOTE:-https://gitee.com/${REPO}.git} 然后保存退出，再执行一下，一般就应该安装好了。\n将系统默认shell切换为zsh\n# 切换默认shell chsh -s $(which zsh) # 确认是否切换成功 echo $SHELL 安装Zsh主题和插件 # powerlevel10k主题 git clone https://github.com/romkatv/powerlevel10k.git $ZSH_CUSTOM/themes/powerlevel10k # zsh-autosuggestions自动提示插件 git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions # zsh-syntax-highlighting语法高亮插件 git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting # 配置powerlevel10k，选择各种样式 p10k configure 在~/.zshrc文件启用插件和主题\n# 修改主题 ZSH_THEME=\u0026#34;powerlevel10k/powerlevel10k\u0026#34; # 启用插件 plugins=( git zsh-autosuggestions zsh-syntax-highlighting ) [参考文档](Linux终端环境配置 | GeekHour)\n","permalink":"https://dueplay.github.io/posts/zsh/","summary":"安装 ubuntu系统默认的shell是bash，可以使用echo $SHELL命令来查看当前使用的shell，zsh是bash的一个替代品，它的功能更加强大和丰富，可以使用cat /etc/shells来查看支持的shell\n如果结果中没有zsh的话就需要使用下面的命令来安装一下：\nsudo apt install zsh -y 安装字体 这里安装powerlevel10k主题推荐使用的MesloLGS-Nerd字体。\n一般在初次安装配置主题的时候会默认提示安装，但是如果没有正常安装的话也可以使用下面的内容来手动安装一下： MesloLGS字体ttf文件下载地址：\nwget https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS%20NF%20Regular.ttf \u0026amp;\u0026amp; wget https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS%20NF%20Bold.ttf \u0026amp;\u0026amp; wget https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS%20NF%20Italic.ttf \u0026amp;\u0026amp; wget https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS%20NF%20Bold%20Italic.ttf 安装完成之后在系统设置或者各个软件比如终端或者VSCode上把字体设置为MesloLGS NF就可以了。\n# 将下载的字体拷贝至truetype sudo cp ttf/*.ttf /usr/share/fonts/truetype/ # 安装fontconfig sudo apt install fontconfig # 刷新字体缓存 fc-cache -fv 安装Oh-My-Zsh sh -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026#34; 慢或者失败的小伙伴可以换成国内源:\nwget https://gitee.com/mirrors/oh-my-zsh/raw/master/tools/install.sh 下载之后给install.sh添加执行权限：\nchmod +x install.sh 然后还需要修改一下安装脚本中的远程仓库地址：\n打开install.sh文件，找到以下部分：\n# Default settings ZSH=${ZSH:-~/.oh-my-zsh} REPO=${REPO:-ohmyzsh/ohmyzsh} REMOTE=${REMOTE:-https://github.com/${REPO}.git} BRANCH=${BRANCH:-master} 将中间两行修改为下面这样，使用gitee镜像：\nREPO=${REPO:-mirrors/ohmyzsh} REMOTE=${REMOTE:-https://gitee.com/${REPO}.git} 然后保存退出，再执行一下，一般就应该安装好了。\n将系统默认shell切换为zsh","title":"zsh安装与配置"},{"content":"chrono库主要包含三种类型的类：时间间隔duration、时钟clocks、时间点time point\n1.duration 用来记录时间长度，可以表示几秒、几分钟、几个小时的时间间隔\n// duration的定义，定义于头文件 \u0026lt;chrono\u0026gt; template\u0026lt; class Rep, class Period = std::ratio\u0026lt;1\u0026gt; \u0026gt; class duration; //表示Rep个Period，一个period是一个ratio类，默认为1s // ratio的定义，定义于头文件 \u0026lt;ratio\u0026gt; template\u0026lt; std::intmax_t Num, std::intmax_t Denom = 1 \u0026gt; class ratio; // 代表 Num / Denom 秒，分母默认为1，ratio\u0026lt;2\u0026gt;代表一个时钟周期是2秒 为了方便使用，在标准库中定义了一些常用的时间间隔,定义如下\n纳秒：using std::chrono::nanoseconds = duration\u0026lt;Rep*/*Rep至少 64 位的有符号整数类型*/*, std::nano\u0026gt;; std::nano 为 ratio\u0026lt;1,10e9\u0026gt; 微秒：std::chrono::microseconds\tduration\u0026lt;Rep*/*至少 55 位的有符号整数类型*/*, std::micro\u0026gt; 毫秒：std::chrono::milliseconds\tduration\u0026lt;Rep*/*至少 45 位的有符号整数类型*/*, std::milli\u0026gt; 秒： std::chrono::seconds\tduration\u0026lt;Rep*/*至少 35 位的有符号整数类型*/*\u0026gt; 分钟：std::chrono::minutes\tduration\u0026lt;Rep*/*至少 29 位的有符号整数类型*/*, std::ratio\u0026lt;60\u0026gt;\u0026gt; std::chrono::minutes m(1);//表示1m 小时：std::chrono::hours\tduration\u0026lt;Rep*/*至少 23 位的有符号整数类型*/*, std::ratio\u0026lt;3600\u0026gt;\u0026gt; 构造函数\n// 1. 拷贝构造函数 duration( const duration\u0026amp; ) = default; // 2. 通过指定时钟周期的类型来构造对象 template\u0026lt; class Rep2 \u0026gt; constexpr explicit duration( const Rep2\u0026amp; r ); // 3. 通过指定时钟周期类型，和时钟周期长度来构造对象 template\u0026lt; class Rep2, class Period2 \u0026gt; constexpr duration( const duration\u0026lt;Rep2,Period2\u0026gt;\u0026amp; d ); // 还重载了以下操作符 operator=; operator+; operator-; operator++; operator++(int); operator--; operator--(int); +=,-=,*=,/=,%=; //获取时间间隔的时钟周期个数 constexpr rep count() const; example\nstd::chrono::hour h(2);// h表示2小时的时间间隔对象 std::chrono::millisecond ms{3};// ms表示3毫秒 std::chrono::duration\u0026lt;int,ratio\u0026lt;60\u0026gt;\u0026gt; ten_m(3); // 3个60秒 std::chrono::duration\u0026lt;double,ratio\u0026lt;1,1000\u0026gt;\u0026gt; ms_(5.5); // 5.5个1ms，也计是5.5ms std::chrono::minute t1(1); std::chrono::second t2(20); std::chrono::second t3 = t1 - t2;//1m - 30s = 30s,t3为30s duration的加减运算有一定的规则，当两个duration时钟周期不相同的时候，会先统一成一种时钟，然后再进行算术运算，统一的规则如下：假设有ratio\u0026lt;x1,y1\u0026gt; 和 ratio\u0026lt;x2,y2\u0026gt;两个时钟周期，首先需要求出x1，x2的最大公约数X，然后求出y1，y2的最小公倍数Y，统一之后的时钟周期ratio为ratio\u0026lt;X,Y\u0026gt;。分子求公约，分母求公倍。因为是x1 / y1 - x2 / y2,就通分呗，化为 X/Y,x1/y1可以表示为多少个 X/Y， x2 / y2同理。\nratio\u0026lt;9, 7\u0026gt;和ratio\u0026lt;6, 5\u0026gt;，统一之后的时钟周期ratio\u0026lt;3, 35\u0026gt;，一个ratio\u0026lt;9, 7\u0026gt;就表示为15个ratio\u0026lt;3, 35\u0026gt;，而ratio\u0026lt;6, 5\u0026gt;可表示为14个ratio\u0026lt;3, 35\u0026gt;。单位就统一了。\n2.时间点 time point 一个表示时间点的类，定义如下\n该类通常配合clock一起使用\n// 定义于头文件 \u0026lt;chrono\u0026gt; template\u0026lt; class Clock, class Duration = typename Clock::duration \u0026gt; class time_point; // Clock：此时间点time_point在此时钟Clock上计量 // 用于计量从纪元起时间的 std::chrono::duration 类型，表示从clock时间持续duration段时间的时间点 // 构造函数 // 1. 构造一个以新纪元(epoch，即：1970.1.1)作为值的对象，需要和时钟类一起使用，不能单独使用该无参构造函数 time_point(); // 2. 构造一个对象，表示一个时间点，这个时间点为从epoch开始持续d这么一个时间间隔，需要和时钟类一起使用，不能单独使用该构造函数 explicit time_point( const duration\u0026amp; d ); // 3. 拷贝构造函数，构造与t相同时间点的对象，使用的时候需要指定模板参数 template\u0026lt; class Duration2 \u0026gt; time_point( const time_point\u0026lt;Clock,Duration2\u0026gt;\u0026amp; t ); //用来获得1970年1月1日到time_point对象中记录的时间点经过的时间间隔（duration），函数原型如下： duration time_since_epoch() const; // 此外还有很多重载operator 3.时钟Clock chrono库中提供了获取当前的系统时间的时钟类，包含的时钟一共有三种：\nsystem_clock：系统的时钟，系统的时钟可以修改，甚至可以网络对时，因此使用系统时间计算时间差可能不准。 steady_clock：是固定的时钟，相当于秒表。开始计时后，时间只会增长并且不能修改，适合用于记录程序耗时 high_resolution_clock：和时钟类 steady_clock 是等价的，精度更高（是它的别名）。\n每个时钟类内部成员有time_point、duration、Rep、Period等信息，基于这些信息来获取当前时间，以及实现time_t和time_point之间的相互转换。\n在使用chrono提供的时钟类的时候，不需要创建类对象，直接调用类的静态方法就可以得到想要的时间了。\n3.1system_clock 定义\nstruct system_clock { // using 定义别名 using rep = long long; using period = ratio\u0026lt;1, 10\u0026#39;000\u0026#39;000\u0026gt;; // 100 纳秒 using duration = chrono::duration\u0026lt;rep, period\u0026gt;;//时间间隔为rep*period 100纳秒 using time_point = chrono::time_point\u0026lt;system_clock\u0026gt;; //时间点通过系统时钟做了初始化 static constexpr bool is_steady = false; _NODISCARD static time_point now() noexcept { // get current time，返回表示当前时间的时间点。 return time_point(duration(_Xtime_get_ticks())); } _NODISCARD static __time64_t to_time_t(const time_point\u0026amp; _Time) noexcept { // convert to __time64_t，将 time_point 时间点类型转换为 std::time_t 类型 return duration_cast\u0026lt;seconds\u0026gt;(_Time.time_since_epoch()).count(); } _NODISCARD static time_point from_time_t(__time64_t _Tm) noexcept { // convert from __time64_t，将 std::time_t 类型转换为 time_point 时间点类型 return time_point{seconds{_Tm}}; } }; example\n#include \u0026lt;chrono\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { // 新纪元1970.1.1时间 std::chrono::system_clock::time_point epoch; std::chrono::duration\u0026lt;int,std::ratio\u0026lt;60 * 60 * 24\u0026gt;\u0026gt; day(1); // 新纪元1970.1.1时间 + 1天 std::chrono::system_clock::time_point ppt(day); using day_t = std::chrono::duration\u0026lt;int, std::ratio\u0026lt;60 * 60 * 24\u0026gt;\u0026gt;; // 新纪元1970.1.1时间 + 10天 // std::chrono::time_point需要指定模板参数 std::chrono::time_point\u0026lt;std::chrono::system_clock,day_t\u0026gt; t(day_t(10)); // 系统当前时间 // std::chrono::system_clock::time_point = chrono::time_point\u0026lt;system_clock\u0026gt; std::chrono::system_clock::time_point today = std::chrono::system_clock::now(); // 转换为time_t时间类型 time_t tm = std::chrono::system_clock::to_time_t(today); std::cout \u0026lt;\u0026lt; \u0026#34;今天的日期是: \u0026#34; \u0026lt;\u0026lt; ctime(\u0026amp;tm); time_t tm1 = std::chrono::system_clock::to_time_t(today+day); std::cout \u0026lt;\u0026lt; \u0026#34;明天的日期是: \u0026#34; \u0026lt;\u0026lt; ctime(\u0026amp;tm1); time_t tm2 = std::chrono::system_clock::to_time_t(epoch); std::cout \u0026lt;\u0026lt; \u0026#34;新纪元时间: \u0026#34; \u0026lt;\u0026lt; ctime(\u0026amp;tm2); time_t tm3 = std::chrono::system_clock::to_time_t(ppt); std::cout \u0026lt;\u0026lt; \u0026#34;新纪元时间+1天: \u0026#34; \u0026lt;\u0026lt; ctime(\u0026amp;tm3); time_t tm4 = std::chrono::system_clock::to_time_t(t); std::cout \u0026lt;\u0026lt; \u0026#34;新纪元时间+10天: \u0026#34; \u0026lt;\u0026lt; ctime(\u0026amp;tm4); } 3.2 steady_clock 想要获取程序耗时的时长，可以使用syetem_clock，因为这个时间可以跟随系统的设置发生变化。\nsteady_clock相当于秒表，只要启动就会进行时间的累加，并且不能被修改，\n定义\nstruct steady_clock { // wraps QueryPerformanceCounter using rep = long long;// 通过long long整形来记录时钟周期的个数 using period = nano;// 时钟周期为1纳秒 using duration = nanoseconds; // 时间间隔为1ns using time_point = chrono::time_point\u0026lt;steady_clock\u0026gt;; // 通过steady_clock对时间点进行初始化 static constexpr bool is_steady = true; // get current time _NODISCARD static time_point now() noexcept { // doesn\u0026#39;t change after system boot const long long _Freq = _Query_perf_frequency(); const long long _Ctr = _Query_perf_counter(); static_assert(period::num == 1, \u0026#34;This assumes period::num == 1.\u0026#34;); const long long _Whole = (_Ctr / _Freq) * period::den; const long long _Part = (_Ctr % _Freq) * period::den / _Freq; return time_point(duration(_Whole + _Part)); } }; example\n#include \u0026lt;chrono\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { // 获取开始时间点 std::chrono::steady_clock::time_point start = std::chrono::steady_clock::now(); // 需要获取程序耗时的代码段 std::cout \u0026lt;\u0026lt; \u0026#34;print 1000 stars ....\u0026#34; \u0026lt;\u0026lt; std::endl; for (int i = 0; i \u0026lt; 1000; ++i) { std::cout \u0026lt;\u0026lt; \u0026#34;*\u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; // 获取结束时间点 std::chrono::steady_clock::time_point last = std::chrono::steady_clock::now(); // 计算差值，是一个时间间隔 auto dt = last - start; // dt.count()返回时间间隔中有多少个时钟周期 std::cout \u0026lt;\u0026lt; \u0026#34;总共耗时: \u0026#34; \u0026lt;\u0026lt; dt.count() \u0026lt;\u0026lt; \u0026#34;纳秒\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;总共耗时: \u0026#34; \u0026lt;\u0026lt; dt.count() / (double)1000000 \u0026lt;\u0026lt; \u0026#34;ms\u0026#34; \u0026lt;\u0026lt; std::endl; } 3.3 high_resolution_clock high_resolution_clock提供的时钟精度比system_clock要高，它也是不可以修改的。在底层源码中，这个类其实是steady_clock类的别名\nusing high_resolution_clock = steady_clock; 因此使用方式和steady_clock是一样的\n4.转换函数 4.1duration_cast duration_cast是chrono库提供的一个模板函数，这个函数不属于duration类。通过这个函数可以对duration类对象内部的时钟周期Period，和周期次数的类型Rep进行修改。\n定义如下：\ntemplate \u0026lt;class ToDuration, class Rep, class Period\u0026gt; constexpr ToDuration duration_cast (const duration\u0026lt;Rep,Period\u0026gt;\u0026amp; dtn); // 返回目标类型ToDuration的时间间隔 注意：\n如果是对时钟周期进行转换：源时钟周期必须能够整除目的时钟周期（比如：小时到分钟）。 如果是对时钟周期次数的类型进行转换：低等类型默认可以向高等类型进行转换（比如：int 转 double）。 如果时钟周期和时钟周期次数类型都变了，根据第二点进行推导（也就是看时间周期次数类型）。 以上条件都不满足，那么就需要使用 duration_cast 进行显示转换，比如小的时钟周期转大的时钟周期。\nexample\n#include \u0026lt;chrono\u0026gt; #include \u0026lt;iostream\u0026gt; void f(){ std::cout \u0026lt;\u0026lt; \u0026#34;print 1000 stars ....\u0026#34; \u0026lt;\u0026lt; std::endl; for (int i = 0; i \u0026lt; 1000; ++i) { std::cout \u0026lt;\u0026lt; \u0026#34;*\u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; } int main() { // 获取开始时间点 std::chrono::steady_clock::time_point start = std::chrono::steady_clock::now(); // 需要获取程序耗时的代码段 f(); // 获取结束时间点 std::chrono::steady_clock::time_point last = std::chrono::steady_clock::now(); // 计算差值，是一个为多少ns的时间间隔 auto dt = last - start; // dt.count()返回时间间隔中有多少个时钟周期 std::cout \u0026lt;\u0026lt; \u0026#34;总共耗时: \u0026#34; \u0026lt;\u0026lt; dt.count() \u0026lt;\u0026lt; \u0026#34;纳秒\u0026#34; \u0026lt;\u0026lt; std::endl; // 转换 // 整数时长：时钟周期纳秒转毫秒，小转大，并且是int转int，所以不能直接转，要求 duration_cast auto int_ms = std::chrono::duration_cast\u0026lt;std::chrono::milliseconds\u0026gt;(dt); // 小数时长：int转double，符合第二点，虽然是小转大但不要求 duration_cast std::chrono::duration\u0026lt;double, std::ratio\u0026lt;1, 1000\u0026gt;\u0026gt; fp_ms = dt; std::cout \u0026lt;\u0026lt; \u0026#34;f() took \u0026#34; \u0026lt;\u0026lt; fp_ms.count() \u0026lt;\u0026lt; \u0026#34; ms, \u0026#34; \u0026lt;\u0026lt; \u0026#34;or \u0026#34; \u0026lt;\u0026lt; int_ms.count() \u0026lt;\u0026lt; \u0026#34; whole milliseconds\\n\u0026#34;\u0026lt;\u0026lt; std::endl; } 4.2 time_point_cast time_point_cast也是chrono库提供的一个模板函数，这个函数不属于time_point类。函数的作用是对时间点进行转换，因为不同的时间点对象内部的时钟周期Period，和周期次数的类型Rep可能也是不同的，一般情况下它们之间可以进行隐式类型转换，也可以通过该函数显示的进行转换。\n定义：\ntemplate \u0026lt;class ToDuration, class Clock, class Duration\u0026gt; time_point\u0026lt;Clock, ToDuration\u0026gt; time_point_cast(const time_point\u0026lt;Clock, Duration\u0026gt; \u0026amp;t); example\n#include \u0026lt;chrono\u0026gt; #include \u0026lt;iostream\u0026gt; // 定义别名 using Clock = std::chrono::high_resolution_clock; using Ms = std::chrono::milliseconds; using Sec = std::chrono::seconds; template\u0026lt;class Duration\u0026gt; using TimePoint = std::chrono::time_point\u0026lt;Clock, Duration\u0026gt;;//clock类型为high_resolution_clock void print_ms(const TimePoint\u0026lt;Ms\u0026gt;\u0026amp; time_point) { std::cout \u0026lt;\u0026lt; time_point.time_since_epoch().count() \u0026lt;\u0026lt; \u0026#34; ms\\n\u0026#34;; } int main() { TimePoint\u0026lt;Sec\u0026gt; time_point_sec(Sec(6)); // 无精度损失, 可以进行隐式类型转换 TimePoint\u0026lt;Ms\u0026gt; time_point_ms(time_point_sec); print_ms(time_point_ms); // 6000 ms time_point_ms = TimePoint\u0026lt;Ms\u0026gt;(Ms(6789)); // error，会损失精度，不允许进行隐式的类型转换 TimePoint\u0026lt;Sec\u0026gt; sec(time_point_ms); // 显示类型转换,会损失精度。6789 truncated to 6000 time_point_sec = std::chrono::time_point_cast\u0026lt;Sec\u0026gt;(time_point_ms); print_ms(time_point_sec); // 6000 ms } ","permalink":"https://dueplay.github.io/posts/chrono/","summary":"chrono库主要包含三种类型的类：时间间隔duration、时钟clocks、时间点time point\n1.duration 用来记录时间长度，可以表示几秒、几分钟、几个小时的时间间隔\n// duration的定义，定义于头文件 \u0026lt;chrono\u0026gt; template\u0026lt; class Rep, class Period = std::ratio\u0026lt;1\u0026gt; \u0026gt; class duration; //表示Rep个Period，一个period是一个ratio类，默认为1s // ratio的定义，定义于头文件 \u0026lt;ratio\u0026gt; template\u0026lt; std::intmax_t Num, std::intmax_t Denom = 1 \u0026gt; class ratio; // 代表 Num / Denom 秒，分母默认为1，ratio\u0026lt;2\u0026gt;代表一个时钟周期是2秒 为了方便使用，在标准库中定义了一些常用的时间间隔,定义如下\n纳秒：using std::chrono::nanoseconds = duration\u0026lt;Rep*/*Rep至少 64 位的有符号整数类型*/*, std::nano\u0026gt;; std::nano 为 ratio\u0026lt;1,10e9\u0026gt; 微秒：std::chrono::microseconds\tduration\u0026lt;Rep*/*至少 55 位的有符号整数类型*/*, std::micro\u0026gt; 毫秒：std::chrono::milliseconds\tduration\u0026lt;Rep*/*至少 45 位的有符号整数类型*/*, std::milli\u0026gt; 秒： std::chrono::seconds\tduration\u0026lt;Rep*/*至少 35 位的有符号整数类型*/*\u0026gt; 分钟：std::chrono::minutes\tduration\u0026lt;Rep*/*至少 29 位的有符号整数类型*/*, std::ratio\u0026lt;60\u0026gt;\u0026gt; std::chrono::minutes m(1);//表示1m 小时：std::chrono::hours\tduration\u0026lt;Rep*/*至少 23 位的有符号整数类型*/*, std::ratio\u0026lt;3600\u0026gt;\u0026gt; 构造函数","title":"chrono库的使用"},{"content":"Git Local 1.Check the Version $ git --version 2.Configure Git 我们通常会将 git 配置为我们在 github 上注册的用户名/电子邮件/密码。global 关键字会为系统中的每个版本库设置配置。我们可以去掉 global 关键字，只对当前仓库进行配置。\n# 配置 $ git config --global user.name \u0026#34;Dueplay\u0026#34; $ git config --global user.email \u0026#34;2289535823@qq.com\u0026#34; $ git config --global user.password \u0026#34;your passwd\u0026#34; # 查看配置 $ git config user.name Dueplay $ git config user.email 2289535823@qq.com $ git config user.password hello123 3. Initialize Git 创建一个新的 repo，并如下初始化 git 以跟踪一个文件夹：\n$ mkdir myproject \u0026amp;\u0026amp; cd myproject $ git init 在myproject有个隐藏文件夹 .git ，这是 git 为我们存储所有跟踪信息的地方。\n4. Check Status $ git status On branch master No commits yet Untracked files: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to include in what will be committed) index.html nothing added to commit but untracked files present (use \u0026#34;git add\u0026#34; to track) 5.暂存新的改变到工作区 在Git中，\u0026ldquo;暂存\u0026rdquo;（Staging）指的是将工作目录中的修改或新文件添加到Git的索引中（也称为暂存区），以便随后commit这些更改。暂存的主要目的是允许选择性地commit文件而不是全部文件的修改，通过使用暂存区，可以控制哪些修改被包含在下次commit中。\n在 git 中，每个文件都可能处于两个阶段中的一个：\n已跟踪\u0026ndash;git 会主动监控该文件的任何更改，并将其作为 repo 的一部分 未跟踪\u0026ndash;虽然文件存在，但 git 会 \u0026ldquo;忽略 \u0026ldquo;它的存在和变化\n# $ git add index.html # $ git restore --staged [filename] 6.Commit Changes $ git commit -m \u0026#34;First release of Git Helloworld Project\u0026#34; 可以跳过暂存阶段，一步到位地comiit变更。不建议这样做\ngit commit -a -m [commit message] git tag 用于给 Git 中的commit打上标签（tag），这些标签通常用于标识某个特殊的commit，比如软件版本发布。标签提供了一个稳定的引用，使得方便地回溯到某个特定的commit，常用的命令选项有\n• -a：用于创建一个带注释的标签 • -m：指定标签的注释信息 • -l：列出已有的标签 7. Commit History $ git log # 精简log $ git log --oneline 8.Help git有这么多的标志选项和命令\ngit help \u0026ndash;all 会显示所有可用的 git 命令。\ngit [command] -help 会显示该命令可设置的所有标志，而 git [command] \u0026ndash;help 则会打开该命令的手册。(单\u0026ndash;和双\u0026ndash;）\n9.Git Branch 创建新分支\n$ git branch hello-world-image 查看这个仓库所有可用的分支\n$ git branch hello-world-image * master 如果我们切换master主分支，新快照就不是主分支的一部分。我们在另一个分支中的新更改不会影响主分支。\n通过 checkout 命令从主分支转移到新创建的分支：\n$ git checkout hello-world-image Switched to branch \u0026#39;hello-world-image\u0026#39; 创建和切换到新分支可一步完成\n$ git checkout -b hello-world-image 删除分支\ngit branch -d \u0026lt;branch-name\u0026gt; 如果分支有未合并的更改，Git会拒绝删除，并提醒先合并或解决冲突。当然也可以强制删除分支，包括未合并的修改。\ngit branch -D \u0026lt;branch-name\u0026gt; 注意，无法删除主分支、当前所在分支或非分支的内容\n10.Merge Branch git merge 是 Git 中用于合并不同分支的命令。将两个或多个分支的历史和更改集成到一个新的commit中的过程。合并操作通常用于将一个分支的变更合并到另一个分支，以确保这两个分支包含了相同的代码更改。假设我们对 hello-world-image 分支中的新开发非常满意，决定将其合并回主分支。注意master上是没有新提交的。\n既然要合并到主分支，我们首先要确保自己是站在主分支上的：\n$ git checkout master Switched to branch \u0026#39;master\u0026#39; # 使用merge合并分支，将指定分支中的更改合并到当前分支master $ git merge hello-world-image Updating 2daa287..c31a2c0 Fast-forward img_hello_world.png | Bin 0 -\u0026gt; 48630 bytes 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 img_hello_world.png 我们看到 git 说这次合并是 \u0026ldquo;Fast-forward\u0026rdquo;，因为它没有发现这两个分支有任何冲突，合并进行得很顺利。\n然而，生活并不总是一帆风顺。有时会发生合并冲突。\n假设现在我们回到 hello-world-image，在 index.html 中添加一行新内容。同时，我们在主分支中删除 index.html 中的一行，并在两个分支中都提交更改。\n现在，当我们尝试将此提交与主分支合并时，这种叫做Three-way Merge，冲突就会发生：\n$ git merge hello-world-image Auto-merging index.html CONFLICT (content): Merge conflict in index.html Automatic merge failed; fix conflicts and then commit the result. 我们可以打开 index.html，看看 git 对冲突发生的原因和方式做了哪些标记：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Hello World!\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;bluestyle.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello world!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;This is the first file in my new Git Repo.\u0026lt;/p\u0026gt; \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; HEAD ======= \u0026lt;p\u0026gt;A old line in our file!\u0026lt;/p\u0026gt; \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; hello-world-image \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 我们可以选择保留 \u0026laquo;\u0026laquo;\u0026laquo;\u0026lt; HEAD 至 ======= 之间的所有内容，或者保留 ======= 至 \u0026raquo;\u0026raquo;\u0026raquo;\u0026gt; hello-world-image 之间的所有内容。\n在对 index.html 中的冲突部分做出选择后，我们将文件暂存并提交，以结束这次合并操作。\n$ git add index.html $ git commit -m \u0026#34;after fix the conflict\u0026#34; [master bdfc2b1] after fix the conflict 这样就完成了两个冲突分支的合并，通过 -d 标志，我们可以删除合并后的分支，以保持工作区的整洁：\n$ git branch -d hello-world-images Deleted branch hello-world-image (was 9e7a8ee). --no-ff 选项用于强制创建一个新的合并commit，即使可以执行快速前进合并，这样可以保留每个分支的独立历史\ngit merge --no-ff \u0026lt;branch-name\u0026gt; 要执行Fast-forward 合并：\ngit merge --ff \u0026lt;branch-name\u0026gt; 11.Revert revert 命令用于删除之前的提交，并将删除内容变成新的提交，而不修改日志。\n首先，我们要检查哪个提交是我们想要返回的：（使用 \u0026ndash;oneline 关键字显示简洁的 git 日志）\n$ git log --oneline bdfc2b1 (HEAD -\u0026gt; master) fix conflicts: 9e7a8ee add a line 17fd1f5 remove a line 5ec2abb a small change c31a2c0 Added image to Hello World 2daa287 Another changes 48d7a59 First release of Git Helloworld Project $ git revert 9e7a8ee --no-edit 12.Reset 用于将分支的 HEAD 指针和工作目录重置到指定的commit，可以选择是否保留未commit的更改，reset 会将 repo 全部移回之前的提交，会删除该提交和最新版本之间的所有更改。\n现在，假设我们添加了两个文件 file1.txt、file2.txt 和 file3.txt，并将它们包含在两个不同的提交中：\n$ touch file1.txt file2.txt file3.txt $ git add file1.txt \u0026amp;\u0026amp; git commit -m \u0026#34;Add file1\u0026#34; $ git add file2.txt \u0026amp;\u0026amp; git commit -m \u0026#34;Add file2\u0026#34; $ git add file3.txt \u0026amp;\u0026amp; git commit -m \u0026#34;Add file3\u0026#34; $ git log --oneline 327ae72 (HEAD -\u0026gt; master) Add file3 8b159b4 Add file2 cf9f3bf Add file1 ...(more)... 现在我们不需要文件 2 和文件 3，但希望保留文件 1。我们可以分别revert最近的 2 次提交，或者reset回添加 file1 的提交。\n$ git reset cf9f3bf $ git log cf9f3bf (HEAD -\u0026gt; master) Add file1 ...(more)... 警告：通常情况下，乱动版本库的提交历史是很危险的，尤其是在与他人合作时。\n如果我们知道 git 的提交哈希值，就有办法撤销reset。在前面的例子中，即使我们reset回 file1 的提交，我们仍然可以返回，因为我们知道上次添加文件 3 的提交哈希值是 327ae72。\n$ git reset 327ae72 $ git log 327ae72 (HEAD -\u0026gt; master) Add file3 8b159b4 Add file2 cf9f3bf Add file1 ...(more)... reset其实有三个主要的选项：--soft、--mixed 和 --hard，对应于不同的重置模式\ngit reset \u0026ndash;soft ：回退 HEAD 指针到指定的commit，但保留所有的更改。即不会修改工作目录或暂存区，所有的更改都被标记为未commit的更改，可以直接重新commit\ngit reset \u0026ndash;mixed ：默认的reset模式。回退 HEAD 指针到指定的commit，并且重置暂存区，但保留工作目录中的更改。即未commit的更改会保留在工作目录，但不会被标记为暂存区的更改，需要重新add并commit\ngit reset \u0026ndash;hard ：最彻底的reset模式。回退 HEAD 指针到指定的commit，重置暂存区，并删除工作目录中未commit的更改，慎用这个玩意，因为它会永久性地删除未commit的更改\n13.Amend commit \u0026ndash;amend 可用于修改最近的提交，并交换更改其提交信息。\n它将暂存区域的改动与最新提交结合起来，并从中创建一个新提交，取代最新提交。\n例如，我们对 README.md 稍作改动，想要提交，但在提交信息中输入了不少错别字。\n$ git add README.md $ git commit -m \u0026#34;Upated: RMEADE.md (ugly typos)\u0026#34; $ git log --oneline b0dfb07 (HEAD -\u0026gt; master) Upated: RMEADE.md (ugly typos) 327ae72 Add file3 ...(more)... 我们的错别字让 git 历史看起来很糟糕。使用amend修改提交语句\n$ git commit --amend -m \u0026#34;Update: README.md (beautiful)\u0026#34; $ git log --oneline d4bf700 (HEAD -\u0026gt; master) Update: README.md (beautiful) 327ae72 Add file3 ...(more)... 14.stash git stash 是一个用于保存当前工作目录和暂存区的临时状态的命令。允许在切换分支、应用补丁或执行其他操作之前，将当前的修改存储起来，以便稍后重新应用，非常非常实用，常见的使用场景如\n\\1. 保存当前工作目录和暂存区的状态 git stash save \u0026#34;Work in progress\u0026#34; \\2. 切换到其他分支进行操作 git checkout other-branch \\3. 在其他分支进行操作 # 在 other-branch 上进行一些操作 \\4. 切回原始分支并恢复 stash git checkout original-branch git stash apply 或者，如果想同时删除 stash，可以使用：\ngit stash pop 此外，还有一些其他常用命令\ngit stash list # 显示 Git 存储库中所有存储的列表，以及有关每个存储的一些信息 git stash branch \u0026lt;branch-name\u0026gt; # 将更改应用到不同的分支 2.Git Remote 首先需要创建一个新的 github 仓库，然后上传我们目前正在开发的本地仓库，以便同步。\n为了方便起见，我们将远程仓库也命名为 myproject。\n1.与远程仓库同步 在本地项目仓库中，我们需要添加一个远程跟踪链接：\ngit remote add origin https://github.com/Dueplay/myproject.git 通过 git remote -v 检查是否与 github 上的 repo 远程同步\n$ git remote -v origin\thttps://github.com/[username]/myproject.git (fetch) origin\thttps://github.com/[username]/myproject.git (push) 然后，我们就可以将所有本地开发的内容推送到远程版本库：\ngit push：将本地更改推送到远程仓库的命令，完整格式 ：git push \u0026lt;remote\u0026gt; 是远程仓库的名称，通常是 \u0026ldquo;origin\u0026rdquo; 或其他你设置的别名。 \u0026lt;branch\u0026gt; 是本地分支的名称，它将被推送到远程仓库的同名分支。 \u0026ndash;set-upstream（或者简写为 -u）: 这部分告诉Git为本地分支与远程分支建立关联关系。关联关系的作用是在将来的推送或拉取操作中，Git会自动识别要使用的远程分支。设置关联关系后，你就可以使用git push和git pull而不需要每次都指定远程仓库和分支,只需输入 git push，Git 将自动使用关联的远程和分支。\n$ git push --set-upstream origin master Enumerating objects: 34, done. Counting objects: 100% (34/34), done. Delta compression using up to 8 threads Compressing objects: 100% (33/33), done. Writing objects: 100% (34/34), 49.37 KiB | 12.34 MiB/s, done. Total 34 (delta 17), reused 0 (delta 0), pack-reused 0 remote: Resolving deltas: 100% (17/17), done. To https://github.com/[username]/myproject.git * [new branch] master -\u0026gt; master Branch \u0026#39;master\u0026#39; set up to track remote branch \u0026#39;master\u0026#39; from \u0026#39;origin\u0026#39;. /*你的本地 master 分支现在已设置为跟踪远程仓库 \u0026#39;origin\u0026#39; 上的远程 master 分支*/ 现在，我们已将本地所有开发成果上传到远程版本库\n2.拉取远程仓库新东西到本地 现在，假设远程 repo 上出现了新情况。在此，我们将模拟这种情况，直接从 github 上的 README.md 中移除一行并提交。\n我们如何更新本地版本库以包含这些更改呢？\n我们有两个选择：\nfetch + merge pull 从第一个组合开始。我们首先需要使用 fetch 从远程下载所有新更改\n$ git fetch origin remote: Enumerating objects: 5, done. remote: Counting objects: 100% (5/5), done. remote: Compressing objects: 100% (1/1), done. remote: Total 3 (delta 2), reused 2 (delta 2), pack-reused 0 Unpacking objects: 100% (3/3), 689 bytes | 344.00 KiB/s, done. From https://github.com/[username]/myproject d4bf700..6d4ad42 master -\u0026gt; origin/master # 现在我们有了来自远程的新改动，可以检查一下 git 状态了： $ git status On branch master Your branch is behind \u0026#39;origin/master\u0026#39; by 1 commit, and can be fast-forwarded. (use \u0026#34;git pull\u0026#34; to update your local branch) 我们看到本地仓库比上游主仓库晚提交了 1 次，即 README.md 上的一行改动。我们可以使用 git diff 命令仔细检查具体的差异\n$ git diff origin/master diff --git a/README.md b/README.md index f3fa9a9..cf28200 100644 --- a/README.md +++ b/README.md @@ -3,3 +3,5 @@ Hello World repository for Git tutorial This is an example repository for the Git tutoial on https://www.w3schools.com This repository is built step by step in the tutorial. + +a new line 合并提交\n$ git merge origin/master Updating d4bf700..6d4ad42 Fast-forward README.md | 2 -- 1 file changed, 2 deletions(-) $ git status On branch master Your branch is up to date with \u0026#39;origin/master\u0026#39;. 现在我们的本地 git 已经是最新的了。\n上述方法可行，但有点繁琐。其实我们可以用 pull 命令一步完成更新，它是 fetch 和 merge 的结合。\n让我们把从远程 github 上的 README.md 中删除的新行添加回去，并尝试把更改拉入本地 git。\n$ git pull origin remote: Enumerating objects: 5, done. remote: Counting objects: 100% (5/5), done. remote: Compressing objects: 100% (3/3), done. remote: Total 3 (delta 2), reused 0 (delta 0), pack-reused 0 Unpacking objects: 100% (3/3), 696 bytes | 232.00 KiB/s, done. From https://github.com/[username]/myproject 6d4ad42..b2bb9ae master -\u0026gt; origin/master Updating 6d4ad42..b2bb9ae Fast-forward README.md | 2 ++ 1 file changed, 2 insertions(+) 可以看到我们已经更新了远程主分支：\n$ git log --oneline b2bb9ae (HEAD -\u0026gt; master, origin/master) Add back a new line from github directly 6d4ad42 Remove the new line README.md GitHub directly d4bf700 Update: README.md (beautiful) 327ae72 Add file3 8b159b4 Add file2 cf9f3bf Add file1 ...(more)... git pull 和 git fetch 都是用于从远程仓库获取更新的 Git 命令，但区别为\ngit fetch origin • 从远程仓库获取更新的信息，但并不自动合并或更新本地工作目录， 只是把远程分支的引用和相关对象（commit、tree等）下载到本地，需要手动合并或者在需要的时候将远程分支的变更整合到本地分支上 git pull origin master • 从远程仓库获取更新的信息，并尝试将本地工作目录自动合并到获取的更新中 • git pull 实际上包含了 git fetch，比如在执行 git fetch 之后，立即执行 git merge 也可以将远程分支的更改合并到当前本地分支 3.推送本地新修改到远程 现在，我们将通过 push 命令为远程仓库做出贡献。\n让我们在 README.md 中再添加一行，然后尝试更新远程版本库。\n$ git commit -a -m \u0026#34;Update readme locally and try push\u0026#34; [master f8986b8] Update readme locally and try push 1 file changed, 1 insertion(+) $ git status On branch master Your branch is ahead of \u0026#39;origin/master\u0026#39; by 1 commit. (use \u0026#34;git push\u0026#34; to publish your local commits) Git 显示我们比远程主分支早提交 1 次。让我们把更改推送到远程仓库。\n$ git push origin 4.Remote Branch Pull 可以通过github图形用户界面直接在远程仓库创建一个新分支。我们从主分支创建了一个名为 secondary 的新分支，并对 README.md 做了一些修改，直接在 github 上提交。\n我们可以将新分支拉到本地 git 并检查它：\n$ git pull remote: Enumerating objects: 5, done. remote: Counting objects: 100% (5/5), done. remote: Compressing objects: 100% (3/3), done. remote: Total 3 (delta 2), reused 0 (delta 0), pack-reused 0 Unpacking objects: 100% (3/3), 697 bytes | 232.00 KiB/s, done. From https://github.com/[username]/myproject * [new branch] secondary -\u0026gt; origin/secondary Already up to date. 我们可以像往常一样通过 git 分支查看新分支。但默认情况下，它只显示本地分支。我们需要使用 -a 标志来查看所有本地和远程分支，或者使用 -r 标志来查看远程分支。\n$ git branch // only local branches * master $ git branch -a * master remotes/origin/master remotes/origin/secondary $ git branch -r origin/master origin/secondary 删除远程仓库中的分支\ngit push origin --delete \u0026lt;branch-name\u0026gt; 5.将本地分支推送到远程 我们也可以将本地新分支的变更推送到远程 repo。\n$ git checkout -b local-new-branch ... (do some changes to README.md) ... $ git commit -a -m \u0026#34;Update from local-new-branch\u0026#34; [local-new-branch 40e9ee3] Update: local-new-branch 1 file changed, 2 insertions(+) $ git push origin local-new-brancch Enumerating objects: 5, done. Counting objects: 100% (5/5), done. Delta compression using up to 8 threads Compressing objects: 100% (3/3), done. Writing objects: 100% (3/3), 334 bytes | 334.00 KiB/s, done. Total 3 (delta 2), reused 0 (delta 0), pack-reused 0 remote: Resolving deltas: 100% (2/2), completed with 2 local objects. remote: remote: Create a pull request for \u0026#39;local-new-branch\u0026#39; on GitHub by visiting: remote: https://github.com/[username]/myproject/pull/new/local-new-branch remote: To https://github.com/[username]/myproject.git * [new branch] local-new-branch -\u0026gt; local-new-branch 现在，如果我们访问 github 远程仓库，就会发现有一个新推送的分支，名为 local-new-branch\n6.Merge Into Master 如上所述，在 github repo 页面上，我们希望将本地-新分支中的更改合并到主分支中。网页上有 \u0026quot; Compare \u0026amp; Pull Request.\u0026ldquo;选项。\n我们可以点击它并创建一个pull request请求。\n因为这是我们自己的 repo，所以我们是 \u0026ldquo;权威\u0026rdquo;，可以直接点击 \u0026ldquo;Merge pull request \u0026ldquo;将更改合并到主分支。\n但在现实生活中，拉取请求通常需要经过代码审查和测试流程，并由合作者验证。如果获得批准，拉取请求才会通过并被合并。\n7.clone and fork $ git clone [the repo url] [the folder path we want to clone into] 8.Git Ignore 我们并不一定希望 git 追踪本地仓库中的每一个文件。可能有一些日志文件、临时文件或个人文件不应该被纳入 git 工作流。\n为了解决这个问题，我们可以在 git 仓库中创建一个 .gitignore 文件，这样 git 就会忽略其中指定的文件。不过，.gitignore 文件本身会被 git 追踪。\n常见的用法包括\ncommand Description blank lines are ignored # something lines start with # is comment and ignored name All name files and folders name/ All folders called name name.file All name.file in repo *.file any file with extension .file !*.file negate any previous ignore on this file 8.remove origin 使用下面命令可将指向仓库的远程 URL 先去除，就能添加其他仓库的地址\ngit remote remove origin git remote add origin https://github.com/xxx ","permalink":"https://dueplay.github.io/posts/git/","summary":"Git Local 1.Check the Version $ git --version 2.Configure Git 我们通常会将 git 配置为我们在 github 上注册的用户名/电子邮件/密码。global 关键字会为系统中的每个版本库设置配置。我们可以去掉 global 关键字，只对当前仓库进行配置。\n# 配置 $ git config --global user.name \u0026#34;Dueplay\u0026#34; $ git config --global user.email \u0026#34;2289535823@qq.com\u0026#34; $ git config --global user.password \u0026#34;your passwd\u0026#34; # 查看配置 $ git config user.name Dueplay $ git config user.email 2289535823@qq.com $ git config user.password hello123 3. Initialize Git 创建一个新的 repo，并如下初始化 git 以跟踪一个文件夹：\n$ mkdir myproject \u0026amp;\u0026amp; cd myproject $ git init 在myproject有个隐藏文件夹 .","title":"Git Tutorial"},{"content":"ssh方式A主机免密登录B\n1.首先在A主机上执行命令\nssh-keygen -t rsa 会在执行命令的当前用户的家目录下的.ssh中生成公钥和私钥，id_rsa和id_rsa.pub分别存放私钥和公钥。\n2.将公钥加入到B主机的~/.ssh/authorized_keys文件中\nscp方式or手动复制粘贴。\nscp ~/.ssh/id_rsa.pub root@B主机ip:~/ B主机上执行：\ncat ~/id_rsa.pub\u0026gt;\u0026gt;~/.ssh/authorized_keys 3.如果不能登录检查以下注意的点和检查/etc/ssh/sshd_config，确保以下配置打开。\nRSAAuthentication yes PubkeyAuthentication yes AuthorizedKeysFile .ssh/authorized_keys 需要注意的几点： 1、确保A机器私钥文件名是id_rsa，否则会因为识别不到私钥文件而不会执行免密rsa登录；\n2、确保B机器上.ssh/authorized_keys文件的属性是600，否则要使用命令、\nchmod 600 ~/.ssh/authorized_keys 更改属性。 3、authorized_keys存放的目录需要与登录用户对应，比如使用root用户登录，则是在/home/root/.ssh/authorized_keys\n","permalink":"https://dueplay.github.io/posts/ssh%E6%96%B9%E5%BC%8Fa%E4%B8%BB%E6%9C%BA%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95b/","summary":"ssh方式A主机免密登录B\n1.首先在A主机上执行命令\nssh-keygen -t rsa 会在执行命令的当前用户的家目录下的.ssh中生成公钥和私钥，id_rsa和id_rsa.pub分别存放私钥和公钥。\n2.将公钥加入到B主机的~/.ssh/authorized_keys文件中\nscp方式or手动复制粘贴。\nscp ~/.ssh/id_rsa.pub root@B主机ip:~/ B主机上执行：\ncat ~/id_rsa.pub\u0026gt;\u0026gt;~/.ssh/authorized_keys 3.如果不能登录检查以下注意的点和检查/etc/ssh/sshd_config，确保以下配置打开。\nRSAAuthentication yes PubkeyAuthentication yes AuthorizedKeysFile .ssh/authorized_keys 需要注意的几点： 1、确保A机器私钥文件名是id_rsa，否则会因为识别不到私钥文件而不会执行免密rsa登录；\n2、确保B机器上.ssh/authorized_keys文件的属性是600，否则要使用命令、\nchmod 600 ~/.ssh/authorized_keys 更改属性。 3、authorized_keys存放的目录需要与登录用户对应，比如使用root用户登录，则是在/home/root/.ssh/authorized_keys","title":"配置ssh免密登录"},{"content":"一、gcc编译流程 源文件-\u0026gt;预处理-\u0026gt;编译-\u0026gt;汇编-\u0026gt;链接-\u0026gt;可执行文件\n1.预处理：cpp，宏替换，头文件展开，去掉注释。gcc -E hello.c -o hello.i\n2.编译：将.c文件通过gcc编译成汇编语言文件。gcc -S hello.i -o hello.s\n3.汇编：将汇编文件通过汇编器as变成二进制文件。gcc -c hello.s -o hello.o\n4.链接：将hello.o中所调用的库文件通过链接器ld链接到一起，成可执行文件。gcc hello.o -o hello\n一步到位：gcc hello.c -o hello 或gcc -o hello hello.c\n生成目标文件（.o文件）gcc -c hello.c -o hello.o（不写-o就默认生成hello.o）\n二、库的制作 1.静态库 ​\t将源文件编译成目标文件 gcc -c add.c sub.c div.c mul.c\n​\t将.o文件打包成库 ar rcs libmath.a add.o sub.o div.o mul.o\n​\t使用库文件 gcc -o main main.c -I头文件的路径 -L库的路径 -l库名\n2.动态库 ​\t将源文件编译成目标文件 gcc -fpic -c add.c sub.c div.c mul.c\n​\t将.o文件打包成库gcc -shared add.o sub.o div.o mul.o -o libmath.so\n​\t使用库文件 gcc -o main main.c -I头文件的路径 -L库的路径 -l库名（链接器ld）\n3.加载动态库时报错 ​\t系统加载可执行代码时候, 能够知道其所依赖的库的名字, 但是还需要知道所依赖的库的绝对路径。此时就需要系统动态载入器ldd。\n​\t在~/.bashrc文件中添加你的动态库的路径（配置环境变量LD_LIBRARY_PATH）\n​ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:库路径\n​\n","permalink":"https://dueplay.github.io/posts/%E5%88%B6%E4%BD%9Cc%E5%BA%93/","summary":"一、gcc编译流程 源文件-\u0026gt;预处理-\u0026gt;编译-\u0026gt;汇编-\u0026gt;链接-\u0026gt;可执行文件\n1.预处理：cpp，宏替换，头文件展开，去掉注释。gcc -E hello.c -o hello.i\n2.编译：将.c文件通过gcc编译成汇编语言文件。gcc -S hello.i -o hello.s\n3.汇编：将汇编文件通过汇编器as变成二进制文件。gcc -c hello.s -o hello.o\n4.链接：将hello.o中所调用的库文件通过链接器ld链接到一起，成可执行文件。gcc hello.o -o hello\n一步到位：gcc hello.c -o hello 或gcc -o hello hello.c\n生成目标文件（.o文件）gcc -c hello.c -o hello.o（不写-o就默认生成hello.o）\n二、库的制作 1.静态库 ​\t将源文件编译成目标文件 gcc -c add.c sub.c div.c mul.c\n​\t将.o文件打包成库 ar rcs libmath.a add.o sub.o div.o mul.o\n​\t使用库文件 gcc -o main main.c -I头文件的路径 -L库的路径 -l库名\n2.动态库 ​\t将源文件编译成目标文件 gcc -fpic -c add.c sub.c div.","title":"gcc和c库的制作"},{"content":"一、目录 1./bin：可执行二进制文件的目录，绿色是可执行文件，\n输入命名./date，date可执行文件执行。cat命令，查看文本文件内容，ctrl+c退出。\n2./boot：linux启动时用到的文件。reboot：重启。\n3./dev：存放设备文件，一切皆文件。\nsudo cat mice鼠标移动，输出。\nsudo临时获得一次管理员权限，cat是查看文件，mice是鼠标文件。\n4./etc：os相关的一些配置文件。cat passwd查看密码。\n5./home：用户的家目录会存在这。Linux系统支持多用户访问。~表示当前用户的家目录。\n6./lib：系统使用的函数库的目录。\n7./root：系统管理员的家目录。普通用户的家目录：/home/cookie。\n切换成管理员账户，sudu su。退出 exit。\n切换普通用户：su 用户名。退出 exit。\ncookie（用户名）@（at在）主机名：当前工作目录$(普通用户)#（管理员）\ncd空格 回车：回到当前用户的“家”目录，宿主目录，这个用户的所有数据。不是home。\ncd空格 - 回到上次工作目录。\n8./tmp：一般用户或正在执行的程序临时存放文件的目录。\n9./usr：unix system resource，应用程序存放目录。\n二、文件类型 linux下不以后缀名区分文件类型。ls -l 查看文件详细信息。\n普通文件-\n目录文件d\n套接字文件s\n软链接文件l\n字符设备文件c\n块设备文件b\n管道文件p\n第一个为文件类型，后面9个，三个一组，r可读，w可写，x可执行。分别为文件所有者权限，所属组权限，其他人的权限。数字2代表硬链接计数。第一个cookie为文件所有者，第二个是所属组。文件所占用的空间大小（byte），最后一次修改时间，文件名。\ngedit 文件名：用记事本编辑文件。\n三、命令 命令格式：命令 -可选 参数\n查看帮助文档：ls \u0026ndash;help；man 1 xxx：1是标准命令，2是系统调用，3是库函数\nctrl+p/n 上/下一条命令\nctrl+u 清空\nctrl+b 光标向前移动一个字符\nctrl+a 光标移动到最前\nctrl+e 光标移动到最后\n通配符：ls std*.h ls std??.h *代表一堆，？代表一个字符。\n输出重定向：\u0026gt;\n追加\u0026raquo;\n删除：rm -f强制删 ；rm -r 递归删（无敌），删目录时必须用这个。\n建立链接文件ln\n查看或合并文件内容：cat，合并要借助重定向。\n拷贝文件：cp 文件名 目录/新名字\n拷贝目录，cp -a保留原有文件格式，创建时间没变；cp -r递归的拷贝，重新创建新的。\n移动文件：mv（移动文件和改名作用） mv 文件名 目录（目录不存在则把文件名改为目录的名字）\nfile：查看文件类型。\n归档管理（压缩打包）：tar zcvf（gzip格式压缩） xxx.tar.gz（压缩包名） yyy1 yyy2 yyy3（yyy为打包材料）\ntar.gz可以不加，但不直观。 z是gzip方式压缩，c是创建，v是展示压缩列表啥东西被打包了，f是指定压缩文件名。\ntar jcvf（bzip2格式压缩） xxx.tar.bz2（压缩包名） yyy1 yyy2 yyy3（yyy为打包材料）\n解压：tar z(j)xvf 压缩包名\n查看命令位置：which ls\n修改文件权限：r：4 w：2 x：1\n7==rwx 5==w-x\nchmod 755 file1\n修改目录里面的所有文件的权限\nchmod 777 dir -R：将dir里面的文件权限全部改为rwx\n查看进程：ps aux\n杀掉经常：kill -9 进程id\n四、vim ","permalink":"https://dueplay.github.io/posts/linux%E5%85%A5%E9%97%A8/","summary":"一、目录 1./bin：可执行二进制文件的目录，绿色是可执行文件，\n输入命名./date，date可执行文件执行。cat命令，查看文本文件内容，ctrl+c退出。\n2./boot：linux启动时用到的文件。reboot：重启。\n3./dev：存放设备文件，一切皆文件。\nsudo cat mice鼠标移动，输出。\nsudo临时获得一次管理员权限，cat是查看文件，mice是鼠标文件。\n4./etc：os相关的一些配置文件。cat passwd查看密码。\n5./home：用户的家目录会存在这。Linux系统支持多用户访问。~表示当前用户的家目录。\n6./lib：系统使用的函数库的目录。\n7./root：系统管理员的家目录。普通用户的家目录：/home/cookie。\n切换成管理员账户，sudu su。退出 exit。\n切换普通用户：su 用户名。退出 exit。\ncookie（用户名）@（at在）主机名：当前工作目录$(普通用户)#（管理员）\ncd空格 回车：回到当前用户的“家”目录，宿主目录，这个用户的所有数据。不是home。\ncd空格 - 回到上次工作目录。\n8./tmp：一般用户或正在执行的程序临时存放文件的目录。\n9./usr：unix system resource，应用程序存放目录。\n二、文件类型 linux下不以后缀名区分文件类型。ls -l 查看文件详细信息。\n普通文件-\n目录文件d\n套接字文件s\n软链接文件l\n字符设备文件c\n块设备文件b\n管道文件p\n第一个为文件类型，后面9个，三个一组，r可读，w可写，x可执行。分别为文件所有者权限，所属组权限，其他人的权限。数字2代表硬链接计数。第一个cookie为文件所有者，第二个是所属组。文件所占用的空间大小（byte），最后一次修改时间，文件名。\ngedit 文件名：用记事本编辑文件。\n三、命令 命令格式：命令 -可选 参数\n查看帮助文档：ls \u0026ndash;help；man 1 xxx：1是标准命令，2是系统调用，3是库函数\nctrl+p/n 上/下一条命令\nctrl+u 清空\nctrl+b 光标向前移动一个字符\nctrl+a 光标移动到最前\nctrl+e 光标移动到最后\n通配符：ls std*.h ls std??.h *代表一堆，？代表一个字符。\n输出重定向：\u0026gt;\n追加\u0026raquo;\n删除：rm -f强制删 ；rm -r 递归删（无敌），删目录时必须用这个。","title":"linux基础知识"},{"content":"1.::作用域运算符 可用::对被屏蔽的同名的全局变量进行访问\n后面有::的名称一定是类名或命名空间名。直接::代表全局作用域下\n通常情况下，如果有两个同名变量，一个是全局变量，另一个是局部变量，那么局部变量在其作用域内具有较高的优先权，它将屏蔽全局变量（就近原则）。\n//全局变量 int a = 10; void test(){ //局部变量 int a = 20; //全局a被隐藏 cout \u0026lt;\u0026lt; \u0026#34;a:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; } 程序的输出结果是a:20。在test函数的输出语句中，使用的变量a是test函数内定义的局部变量，因此输出的结果为局部变量a的值。\n作用域运算符可以用来解决局部变量与全局变量的重名问题\n//全局变量 int a = 10; //1. 局部变量和全局变量同名 void test(){ int a = 20; //打印局部变量a cout \u0026lt;\u0026lt; \u0026#34;局部变量a:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; //打印全局变量a cout \u0026lt;\u0026lt; \u0026#34;全局变量a:\u0026#34; \u0026lt;\u0026lt; ::a \u0026lt;\u0026lt; endl; } 这个例子可以看出，作用域运算符可以用来解决局部变量与全局变量的重名问题，即在局部变量的作用域内，可用::对被屏蔽的同名的全局变量进行访问。\n2.namespace 1.命名空间用途：解决名称冲突\n在game1和game2中都有相同名称的goAtk函数，如果不使用命名空间，会有二义性，编译报错。\n#include \u0026lt;iostream\u0026gt; using namespace std; #include \u0026#34;game1.h\u0026#34; #include \u0026#34;game2.h\u0026#34; void test01(){ LOL::goAtk(); KingGlory::goAtk(); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } game1.h中\n#pragma once #include \u0026lt;iostream\u0026gt; using namespace std; //lol namespace LOL { void goAtk(); } game1.cpp中\n#include \u0026#34;game1.h\u0026#34; void LOL::goAtk() { cout \u0026lt;\u0026lt; \u0026#34;lol的攻击函数\u0026#34; \u0026lt;\u0026lt; endl; } game2.h中\n//王者荣耀 namespace KingGlory { void goAtk(); } 运行结果：\n2.命名空间下可以存放：变量，函数，结构体，类。\n3.命名空间必须声明在全局的作用域下。\n4.命名空间可以嵌套命名空间。\n5.命名空间是开放的，可以随时添加新的成员。\n6.命名空间可以是匿名的\n7.命名空间可以取别名\n//2.命名空间下可以存放：变量，函数，结构体，类 namespace A { int m_A = 10; void func(); struct Person{}; class Animal{}; } //3.命名空间必须声明在全局的作用域下。在局部中定义会报错:不允许进行命名空间定义 void test02() { /*namespace b { };*/ } //4.命名空间可以嵌套命名空间。 namespace B { int m_A = 20; namespace C { int m_A = 30; } } void test03() { cout \u0026lt;\u0026lt; \u0026#34;B命名空间下的m_A = \u0026#34; \u0026lt;\u0026lt; B::m_A \u0026lt;\u0026lt; endl;//20 cout \u0026lt;\u0026lt; \u0026#34;C命名空间下的m_A = \u0026#34; \u0026lt;\u0026lt; B::C::m_A \u0026lt;\u0026lt; endl;//30 } //5.命名空间是开放的，可以随时添加新的成员。 namespace B { int m_B = 40; }//这段代码不会与上面的B冲突，而是合二为一 void test04() { cout \u0026lt;\u0026lt; \u0026#34;B命名空间下的m_A = \u0026#34; \u0026lt;\u0026lt; B::m_A \u0026lt;\u0026lt; endl;//20 cout \u0026lt;\u0026lt; \u0026#34;B命名空间下的m_B = \u0026#34; \u0026lt;\u0026lt; B::m_B \u0026lt;\u0026lt; endl;//40 } //6.命名空间可以是匿名的 namespace { int m_C = 50; int m_D = 50; } void test05() { cout \u0026lt;\u0026lt; \u0026#34;m_C = \u0026#34; \u0026lt;\u0026lt; m_C \u0026lt;\u0026lt; endl;//50 cout \u0026lt;\u0026lt; \u0026#34;m_D = \u0026#34; \u0026lt;\u0026lt; ::m_D \u0026lt;\u0026lt; endl;//50 } //7.命名空间可以取别名 namespace veryLongName { int m_A = 100; } void test06() { namespace veryShortName = veryLongName; cout \u0026lt;\u0026lt; veryLongName::m_A \u0026lt;\u0026lt; endl;//100 cout \u0026lt;\u0026lt; veryShortName::m_A \u0026lt;\u0026lt; endl;//100 } 3.using声明和using编译指令 在开发中通常不自己写命名空间\n#include \u0026lt;iostream\u0026gt; using namespace std; namespace LOL { int sunWuKongId = 1; } namespace KingGlory { int sunWuKongId = 3; } void test01() { //int sunWuKongId = 2; //1.using声明 //注意：using声明和就近原则不要同时出现，尽量避免 //using声明导致“LOL::sunWuKongId”的多次声明 using LOL::sunWuKongId;//告诉编译器使用的是sunWuKongId是LOL里的。 cout \u0026lt;\u0026lt; sunWuKongId \u0026lt;\u0026lt; endl; } void test02() { //int sunWuKongId = 2; //2.using编译指令 //注意：using编译指令和就近原则同时出现，优先使用就近原则 //当使用多个using编译指令，并且出现同名情况，使用数据依然加作用域,不加则不明确 using namespace LOL; using namespace KingGlory; cout \u0026lt;\u0026lt; LOL::sunWuKongId \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; KingGlory::sunWuKongId \u0026lt;\u0026lt; endl; } int main() { test02(); system(\u0026#34;pause\u0026#34;); return 0; } 报错：无法解析的外部命令。是在链接阶段出错了.\n4.函数重载原理 编译器为了实现函数重载，也是默认为我们做了一些幕后的工作，编译器用不同的参数类型来修饰不同的函数名，比如void func();编译器可能将函数名修饰成_func,当编译器碰到void func(int x)，编译器可能将函数名修饰为__func_int;当编译器碰到void func(int x,char c)；编译器可能会将函数名修饰为_func_int_char;我这里使用”可能”这个字眼是因为编译器如何修饰重载的函数名称并没有一个统一的标准，所以不同的编译器可能会产生不同的内部名。\nvoid func(){} void func(int x){} void func(int x,char y){} 以上三个函数在linux下生成的编译之后的函数名为:\n_Z4funcv //v 代表void,无参数\n_Z4funci //i 代表参数为int类型\n_Z4funcic //i 代表第一个参数为int类型，第二个参数为char类型\n5.extern “C”浅析 主要用途：c++中调用c语言的文件\n以下在Linux下测试:\nc函数: void MyFunc(){} ,被编译成函数: MyFunc c++函数: void MyFunc(){},被编译成函数: _Z6Myfuncv 通过这个测试，由于c++中需要支持函数重载，所以c和c++中对同一个函数经过编译后生成的函数名是不相同的，这就导致了一个问题，如果在c++中调用一个使用c语言编写模块中的某个函数，那么c++是根据c++的名称修饰方式来查找并链接这个函数，那么就会发生链接错误，以上例，在c++中调用MyFunc函数，在链接阶段会去找Z6Myfuncv，结果是没有找到的，因为这个MyFunc函数是c语言编写的，生成的符号是MyFunc。\n那么如果我想在c++调用c的函数怎么办？\nextern \u0026ldquo;C\u0026quot;的主要作用就是为了实现c++代码能够调用其他c语言代码。加上extern \u0026ldquo;C\u0026quot;后，这部分代码编译器按c语言的方式进行编译和链接，而不是按c++的方式。\n#ifdef __cplusplus//如果c++编译器在编译这个文件的时候，会有__cplusplus宏，就会将下面代码用c方式链接 extern \u0026#34;C\u0026#34; {//告诉编译器，这个{}中的代码都用c语言的方式来链接 #endif #include \u0026lt;stdio.h\u0026gt; void show(); #ifdef __cplusplus } #endif #include \u0026#34;test.h\u0026#34; void show() { printf(\u0026#34;hello world\\n\u0026#34;); } #include \u0026lt;iostream\u0026gt; using namespace std; #include \u0026#34;test.h\u0026#34; //解决方法1. //告诉编译器 利用c语言的方式链接show函数，这种方式就不用包含头文件了,适合一个函数的情况 //extern \u0026#34;C\u0026#34; void show(); //解决方法2：在.h中添加6行代码 void test01() { show();//show函数是在c语言编写的模块中，编译器如果按照c++的方式去找show， //可能将函数名称修饰为_Z4showv的形式，再去调用。在编译时用c++得方式去链接这个函数 //找的其实是_Z4showv这个名称，找不到这个函数的实现体。 } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } ","permalink":"https://dueplay.github.io/posts/namespace%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/","summary":"1.::作用域运算符 可用::对被屏蔽的同名的全局变量进行访问\n后面有::的名称一定是类名或命名空间名。直接::代表全局作用域下\n通常情况下，如果有两个同名变量，一个是全局变量，另一个是局部变量，那么局部变量在其作用域内具有较高的优先权，它将屏蔽全局变量（就近原则）。\n//全局变量 int a = 10; void test(){ //局部变量 int a = 20; //全局a被隐藏 cout \u0026lt;\u0026lt; \u0026#34;a:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; } 程序的输出结果是a:20。在test函数的输出语句中，使用的变量a是test函数内定义的局部变量，因此输出的结果为局部变量a的值。\n作用域运算符可以用来解决局部变量与全局变量的重名问题\n//全局变量 int a = 10; //1. 局部变量和全局变量同名 void test(){ int a = 20; //打印局部变量a cout \u0026lt;\u0026lt; \u0026#34;局部变量a:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; //打印全局变量a cout \u0026lt;\u0026lt; \u0026#34;全局变量a:\u0026#34; \u0026lt;\u0026lt; ::a \u0026lt;\u0026lt; endl; } 这个例子可以看出，作用域运算符可以用来解决局部变量与全局变量的重名问题，即在局部变量的作用域内，可用::对被屏蔽的同名的全局变量进行访问。\n2.namespace 1.命名空间用途：解决名称冲突\n在game1和game2中都有相同名称的goAtk函数，如果不使用命名空间，会有二义性，编译报错。\n#include \u0026lt;iostream\u0026gt; using namespace std; #include \u0026#34;game1.h\u0026#34; #include \u0026#34;game2.h\u0026#34; void test01(){ LOL::goAtk(); KingGlory::goAtk(); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } game1.","title":"namespace，using，重载，extern c"},{"content":"First time here, just a test. 测试。\n","permalink":"https://dueplay.github.io/posts/hugo-test/","summary":"First time here, just a test. 测试。","title":"Hugo Test"}]