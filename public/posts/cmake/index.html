<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>cmake Tutorial | Cookie&#39;s Blog</title>
<meta name="keywords" content="cmake">
<meta name="description" content="介绍cmake的使用">
<meta name="author" content="Me">
<link rel="canonical" href="https://canonical.url/to/page">
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.ec8da366ca2fb647537ccb7a8f6fa5b4e9cd3c7a0d3171dd2d3baad1e49c8bfc.css" integrity="sha256-7I2jZsovtkdTfMt6j2&#43;ltOnNPHoNMXHdLTuq0eSci/w=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.2eadbb982468c11a433a3e291f01326f2ba43f065e256bf792dbd79640a92316.js" integrity="sha256-Lq27mCRowRpDOj4pHwEybyukPwZeJWv3ktvXlkCpIxY="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="apple-touch-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="mask-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/cmake/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4XHWHM02GB"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-4XHWHM02GB', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="cmake Tutorial" />
<meta property="og:description" content="介绍cmake的使用" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/cmake/" />
<meta property="og:image" content="http://localhost:1313/%3Cimage%20path/url%3E" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-25T14:42:01&#43;08:00" />
<meta property="article:modified_time" content="2023-03-25T14:42:01&#43;08:00" /><meta property="og:site_name" content="ExampleSite" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="http://localhost:1313/%3Cimage%20path/url%3E" />
<meta name="twitter:title" content="cmake Tutorial"/>
<meta name="twitter:description" content="介绍cmake的使用"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "cmake Tutorial",
      "item": "http://localhost:1313/posts/cmake/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "cmake Tutorial",
  "name": "cmake Tutorial",
  "description": "介绍cmake的使用",
  "keywords": [
    "cmake"
  ],
  "articleBody": "文件目录结构 $ tree . ├── add.c ├── div.c ├── head.h ├── main.c ├── mult.c └── sub.c # 指定使用的 cmake 的最低版本，可选，非必须，如果不加可能会有警告 cmake_minimum_required(VERSION 3.0) # 定义工程名称，并可指定工程的版本、工程描述、web主页地址、支持的语言 project(CALC) # 定义工程会生成一个可执行程序，语法add_executable(可执行程序名 源文件名称) add_executable(app add.c div.c main.c mult.c sub.c) # 定义变量，语法: set(VAR VALUE [CACHE TYPE DOCSTRING [FORCE]]).[]里是可选的 # eg.将文件名对应字符串存起来。 # 方式1: 各个源文件之间使用空格间隔 # set(SRC_LIST add.c div.c main.c mult.c sub.c) # 方式2: 各个源文件之间使用分号 ; 间隔 set(SRC_LIST add.c;div.c;main.c;mult.c;sub.c) add_executable(app ${SRC_LIST}) # 指定c++标准 # 使用g++时: $ g++ *.cpp -std=c++11 -o app # C++标准对应有一宏叫做DCMAKE_CXX_STANDARD，在CMake中想要指定C++标准有两种方式： # 在cmakelists.txt中通过 set 命令指定 # 增加-std=c++11 set(CMAKE_CXX_STANDARD 11) # 增加-std=c++14 set(CMAKE_CXX_STANDARD 14) # 增加-std=c++17 set(CMAKE_CXX_STANDARD 17) # 在执行 cmake 命令的时候指定出这个宏的值，-D表示定义宏 #增加-std=c++11 cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=11 #增加-std=c++14 cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=14 #增加-std=c++17 cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=17 # 指定输出的路径，在CMake中指定可执行程序输出的路径，也对应一个宏，叫做EXECUTABLE_OUTPUT_PATH，它的值还是通过set命令进行设置 set(HOME /home/gxj/Linux/Sort) set(EXECUTABLE_OUTPUT_PATH ${HOME}/bin) # 第一行：定义一个变量用于存储一个绝对路径 # 第二行：将拼接好的路径值设置给EXECUTABLE_OUTPUT_PATH宏 # 如果这个路径中的子目录不存在，会自动生成，无需自己手动创建 # 使用相对路径时，./表示生成的makefile所在目录 # 搜索文件 # 如果一个项目里边的源文件很多，在编写CMakeLists.txt文件的时候不可能将项目目录的各个文件一一罗列出来，这样太麻烦也不现实。所以，在CMake中为我们提供了搜索文件的命令，可以使用aux_source_directory命令或者file命令。 # 使用aux_source_directory 命令可以查找某个路径下的所有源文件，命令格式为： aux_source_directory(\u003c dir \u003e \u003c variable \u003e) dir：要搜索的目录 variable：将从dir目录下搜索到的源文件列表存储到该变量中 # 搜索 src 目录下的源文件 aux_source_directory(${CMAKE_CURRENT_SOURCE_DIR}/src SRC_LIST) add_executable(app ${SRC_LIST}) # 使用file 命令 (当然，除了搜索以外通过 file 还可以做其他事情) file(GLOB/GLOB_RECURSE 变量名 要搜索的文件路径和文件类型) GLOB: 将指定目录下搜索到的满足条件的所有文件名生成一个列表，并将其存储到变量中。 GLOB_RECURSE：递归搜索指定目录，将搜索到的满足条件的文件名生成一个列表，并将其存储到变量中。 搜索当前目录的src目录下所有的源文件，并存储到变量中 file(GLOB MAIN_SRC ${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp) file(GLOB MAIN_HEAD ${CMAKE_CURRENT_SOURCE_DIR}/include/*.h) CMAKE_CURRENT_SOURCE_DIR 宏表示当前访问的 CMakeLists.txt 文件所在的路径。 要搜索的文件路径和类型可加双引号，也可不加: file(GLOB MAIN_HEAD \"${CMAKE_CURRENT_SOURCE_DIR}/src/*.h\") # 包含头文件 # 在编译项目源文件的时候，很多时候都需要将源文件对应的头文件路径指定出来，这样才能保证在编译过程中编译器能够找到这些头文件，并顺利通过编译。在CMake中设置要包含的目录也很简单，通过include_directories命令 include_directories(headpath) # 指定就是头文件的路径为项目根目录下面的include include_directories(${PROJECT_SOURCE_DIR}/include) PROJECT_SOURCE_DIR宏对应的值就是我们在使用cmake命令时，后面紧跟的目录，一般是工程的根目录。 # 制作动态库或静态库，源代码并不需要将他们编译生成可执行程序，而是生成一些静态库或动态库提供给第三方使用，下面来是在cmake中生成这两类库文件的方法。 # 在cmake中，如果要制作静态库，需要使用的命令如下：静态库名字分为三部分：lib+库名字+.a，此处只需要指定出库的名字就可以了 add_library(库名称 STATIC 源文件1 [源文件2] ...) # eg include_directories(${PROJECT_SOURCE_DIR}/include) file(GLOB SRC_LIST \"${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp\") add_library(calc STATIC ${SRC_LIST}) # 要制作动态库，需要使用的命令如下，动态库名字分为三部分：lib+库名字+.so，此处只需要指定出库的名字就可以了，另外两部分在生成该文件的时候会自动填充。 add_library(库名称 SHARED 源文件1 [源文件2] ...) add_library(calc SHARED ${SRC_LIST}) # 指定库输出的路径 # 方式1 - 适用于动态库 对于生成的库文件来说和可执行程序一样都可以指定输出路径。由于在Linux下生成的动态库默认是有执行权限的，所以可以按照生成可执行程序的方式去指定它生成的目录： # 设置动态库生成路径，其实就是通过set命令给EXECUTABLE_OUTPUT_PATH宏设置了一个路径，这个路径就是可执行文件生成的路径 set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib) add_library(calc SHARED ${SRC_LIST}) # 方式2 - 都适用 由于在Linux下生成的静态库默认不具有可执行权限，所以在指定静态库生成的路径的时候就不能使用EXECUTABLE_OUTPUT_PATH宏了，而应该使用LIBRARY_OUTPUT_PATH，这个宏对应静态库文件和动态库文件都适用。 # 设置动态库/静态库生成路径 set(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib) # 生成动态库 #add_library(calc SHARED ${SRC_LIST}) # 生成静态库 add_library(calc STATIC ${SRC_LIST}) # 包含库文件 # 链接静态库的命令如下：参数1：指定出要链接的静态库的名字，可以是全名 libxxx.a，也可以是掐头（lib）去尾（.a）之后的名字 xxx。参数2-N：要链接的其它静态库的名字 link_libraries(",
  "wordCount" : "869",
  "inLanguage": "en",
  "image":"http://localhost:1313/%3Cimage%20path/url%3E","datePublished": "2023-03-25T14:42:01+08:00",
  "dateModified": "2023-03-25T14:42:01+08:00",
  "author":{
    "@type": "Person",
    "name": "Me"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/cmake/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Cookie's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/%3Clink%20/%20abs%20url%3E"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Home (Alt + H)">Home</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archives/" title="⏱archives">
                    <span>⏱archives</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="🔍Search">
                    <span>🔍Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="🔖Tags">
                    <span>🔖Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title">
      cmake Tutorial
    </h1>
    <div class="post-description">
      介绍cmake的使用
    </div>
    <div class="post-meta">&lt;span title=&#39;2023-03-25 14:42:01 &#43;0800 CST&#39;&gt;2023-03-25&lt;/span&gt;&amp;nbsp;·&amp;nbsp;5 min&amp;nbsp;·&amp;nbsp;869 words&amp;nbsp;·&amp;nbsp;Me&nbsp;|&nbsp;<a href="https://github.com/Dueplay/blog/content/posts/cmake.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#文件目录结构">文件目录结构</a></li>
        <li><a href="#执行cmake">执行cmake</a></li>
        <li><a href="#cmake-311-fetchcontent模块">CMake 3.11 FetchContent模块</a></li>
      </ul>
    </li>
  </ul>
</nav>
        </div>
    </details>
</div>

  <div class="post-content"><h3 id="文件目录结构">文件目录结构<a hidden class="anchor" aria-hidden="true" href="#文件目录结构">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ tree
</span></span><span class="line"><span class="cl">.
</span></span><span class="line"><span class="cl">├── add.c
</span></span><span class="line"><span class="cl">├── div.c
</span></span><span class="line"><span class="cl">├── head.h
</span></span><span class="line"><span class="cl">├── main.c
</span></span><span class="line"><span class="cl">├── mult.c
</span></span><span class="line"><span class="cl">└── sub.c
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cmake" data-lang="cmake"><span class="line"><span class="cl"><span class="c"># 指定使用的 cmake 的最低版本，可选，非必须，如果不加可能会有警告
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.0</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 定义工程名称，并可指定工程的版本、工程描述、web主页地址、支持的语言
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">project</span><span class="p">(</span><span class="s">CALC</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 定义工程会生成一个可执行程序，语法add_executable(可执行程序名 源文件名称)
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">add_executable</span><span class="p">(</span><span class="s">app</span> <span class="s">add.c</span> <span class="s">div.c</span> <span class="s">main.c</span> <span class="s">mult.c</span> <span class="s">sub.c</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 定义变量，语法: set(VAR VALUE [CACHE TYPE DOCSTRING [FORCE]]).[]里是可选的
</span></span></span><span class="line"><span class="cl"><span class="c"># eg.将文件名对应字符串存起来。
</span></span></span><span class="line"><span class="cl"><span class="c"># 方式1: 各个源文件之间使用空格间隔
</span></span></span><span class="line"><span class="cl"><span class="c"># set(SRC_LIST add.c  div.c   main.c  mult.c  sub.c)
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 方式2: 各个源文件之间使用分号 ; 间隔
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">set</span><span class="p">(</span><span class="s">SRC_LIST</span> <span class="s">add.c;div.c;main.c;mult.c;sub.c</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_executable</span><span class="p">(</span><span class="s">app</span>  <span class="o">${</span><span class="nv">SRC_LIST</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 指定c++标准
</span></span></span><span class="line"><span class="cl"><span class="c"># 使用g++时: $ g++ *.cpp -std=c++11 -o app
</span></span></span><span class="line"><span class="cl"><span class="c"># C++标准对应有一宏叫做DCMAKE_CXX_STANDARD，在CMake中想要指定C++标准有两种方式：
</span></span></span><span class="line"><span class="cl"><span class="c"># 在cmakelists.txt中通过 set 命令指定
</span></span></span><span class="line"><span class="cl"><span class="c"># 增加-std=c++11
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_CXX_STANDARD</span> <span class="s">11</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 增加-std=c++14
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_CXX_STANDARD</span> <span class="s">14</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 增加-std=c++17
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_CXX_STANDARD</span> <span class="s">17</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 在执行 cmake 命令的时候指定出这个宏的值，-D表示定义宏
</span></span></span><span class="line"><span class="cl"><span class="c">#增加-std=c++11
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="err">cmake</span> <span class="err">CMakeLists.txt文件路径</span> <span class="err">-DCMAKE_CXX_STANDARD=11
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c">#增加-std=c++14
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="err">cmake</span> <span class="err">CMakeLists.txt文件路径</span> <span class="err">-DCMAKE_CXX_STANDARD=14
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c">#增加-std=c++17
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="err">cmake</span> <span class="err">CMakeLists.txt文件路径</span> <span class="err">-DCMAKE_CXX_STANDARD=17
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 指定输出的路径，在CMake中指定可执行程序输出的路径，也对应一个宏，叫做EXECUTABLE_OUTPUT_PATH，它的值还是通过set命令进行设置
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">set</span><span class="p">(</span><span class="s">HOME</span> <span class="s">/home/gxj/Linux/Sort</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">EXECUTABLE_OUTPUT_PATH</span> <span class="o">${</span><span class="nv">HOME</span><span class="o">}</span><span class="s">/bin</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 第一行：定义一个变量用于存储一个绝对路径
</span></span></span><span class="line"><span class="cl"><span class="c"># 第二行：将拼接好的路径值设置给EXECUTABLE_OUTPUT_PATH宏
</span></span></span><span class="line"><span class="cl"><span class="c"># 如果这个路径中的子目录不存在，会自动生成，无需自己手动创建
</span></span></span><span class="line"><span class="cl"><span class="c"># 使用相对路径时，./表示生成的makefile所在目录
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 搜索文件
</span></span></span><span class="line"><span class="cl"><span class="c"># 如果一个项目里边的源文件很多，在编写CMakeLists.txt文件的时候不可能将项目目录的各个文件一一罗列出来，这样太麻烦也不现实。所以，在CMake中为我们提供了搜索文件的命令，可以使用aux_source_directory命令或者file命令。
</span></span></span><span class="line"><span class="cl"><span class="c"># 使用aux_source_directory 命令可以查找某个路径下的所有源文件，命令格式为：
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">aux_source_directory</span><span class="p">(</span><span class="s">&lt;</span> <span class="s">dir</span> <span class="s">&gt;</span> <span class="s">&lt;</span> <span class="s">variable</span> <span class="s">&gt;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">dir：要搜索的目录
</span></span></span><span class="line"><span class="cl"><span class="err">variable：将从dir目录下搜索到的源文件列表存储到该变量中
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 搜索 src 目录下的源文件
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">aux_source_directory</span><span class="p">(</span><span class="o">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="o">}</span><span class="s">/src</span> <span class="s">SRC_LIST</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_executable</span><span class="p">(</span><span class="s">app</span>  <span class="o">${</span><span class="nv">SRC_LIST</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 使用file 命令 (当然，除了搜索以外通过 file 还可以做其他事情)
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">file</span><span class="p">(</span><span class="s">GLOB/GLOB_RECURSE</span> <span class="s">变量名</span> <span class="s">要搜索的文件路径和文件类型</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">GLOB:</span> <span class="err">将指定目录下搜索到的满足条件的所有文件名生成一个列表，并将其存储到变量中。
</span></span></span><span class="line"><span class="cl"><span class="err">GLOB_RECURSE：递归搜索指定目录，将搜索到的满足条件的文件名生成一个列表，并将其存储到变量中。
</span></span></span><span class="line"><span class="cl"><span class="err">搜索当前目录的src目录下所有的源文件，并存储到变量中
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">file</span><span class="p">(</span><span class="s">GLOB</span> <span class="s">MAIN_SRC</span> <span class="o">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="o">}</span><span class="s">/src/*.cpp</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">file</span><span class="p">(</span><span class="s">GLOB</span> <span class="s">MAIN_HEAD</span> <span class="o">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="o">}</span><span class="s">/include/*.h</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">CMAKE_CURRENT_SOURCE_DIR</span> <span class="err">宏表示当前访问的</span> <span class="err">CMakeLists.txt</span> <span class="err">文件所在的路径。
</span></span></span><span class="line"><span class="cl"><span class="err">要搜索的文件路径和类型可加双引号，也可不加:
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">file</span><span class="p">(</span><span class="s">GLOB</span> <span class="s">MAIN_HEAD</span> <span class="s2">&#34;${CMAKE_CURRENT_SOURCE_DIR}/src/*.h&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 包含头文件
</span></span></span><span class="line"><span class="cl"><span class="c"># 在编译项目源文件的时候，很多时候都需要将源文件对应的头文件路径指定出来，这样才能保证在编译过程中编译器能够找到这些头文件，并顺利通过编译。在CMake中设置要包含的目录也很简单，通过include_directories命令
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">include_directories</span><span class="p">(</span><span class="s">headpath</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 指定就是头文件的路径为项目根目录下面的include
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">include_directories</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_SOURCE_DIR</span><span class="o">}</span><span class="s">/include</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">PROJECT_SOURCE_DIR宏对应的值就是我们在使用cmake命令时，后面紧跟的目录，一般是工程的根目录。
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 制作动态库或静态库，源代码并不需要将他们编译生成可执行程序，而是生成一些静态库或动态库提供给第三方使用，下面来是在cmake中生成这两类库文件的方法。
</span></span></span><span class="line"><span class="cl"><span class="c"># 在cmake中，如果要制作静态库，需要使用的命令如下：静态库名字分为三部分：lib+库名字+.a，此处只需要指定出库的名字就可以了
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">add_library</span><span class="p">(</span><span class="s">库名称</span> <span class="s">STATIC</span> <span class="s">源文件1</span> <span class="s">[源文件2]</span> <span class="s">...</span><span class="p">)</span> <span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># eg
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">include_directories</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_SOURCE_DIR</span><span class="o">}</span><span class="s">/include</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">file</span><span class="p">(</span><span class="s">GLOB</span> <span class="s">SRC_LIST</span> <span class="s2">&#34;${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_library</span><span class="p">(</span><span class="s">calc</span> <span class="s">STATIC</span> <span class="o">${</span><span class="nv">SRC_LIST</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 要制作动态库，需要使用的命令如下，动态库名字分为三部分：lib+库名字+.so，此处只需要指定出库的名字就可以了，另外两部分在生成该文件的时候会自动填充。
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">add_library</span><span class="p">(</span><span class="s">库名称</span> <span class="s">SHARED</span> <span class="s">源文件1</span> <span class="s">[源文件2]</span> <span class="s">...</span><span class="p">)</span> <span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_library</span><span class="p">(</span><span class="s">calc</span> <span class="s">SHARED</span> <span class="o">${</span><span class="nv">SRC_LIST</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 指定库输出的路径
</span></span></span><span class="line"><span class="cl"><span class="c"># 方式1 - 适用于动态库
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="err">对于生成的库文件来说和可执行程序一样都可以指定输出路径。由于在Linux下生成的动态库默认是有执行权限的，所以可以按照生成可执行程序的方式去指定它生成的目录：
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 设置动态库生成路径，其实就是通过set命令给EXECUTABLE_OUTPUT_PATH宏设置了一个路径，这个路径就是可执行文件生成的路径
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">set</span><span class="p">(</span><span class="s">EXECUTABLE_OUTPUT_PATH</span> <span class="o">${</span><span class="nv">PROJECT_SOURCE_DIR</span><span class="o">}</span><span class="s">/lib</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_library</span><span class="p">(</span><span class="s">calc</span> <span class="s">SHARED</span> <span class="o">${</span><span class="nv">SRC_LIST</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 方式2 - 都适用
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="err">由于在Linux下生成的静态库默认不具有可执行权限，所以在指定静态库生成的路径的时候就不能使用EXECUTABLE_OUTPUT_PATH宏了，而应该使用LIBRARY_OUTPUT_PATH，这个宏对应静态库文件和动态库文件都适用。
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 设置动态库/静态库生成路径
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">set</span><span class="p">(</span><span class="s">LIBRARY_OUTPUT_PATH</span> <span class="o">${</span><span class="nv">PROJECT_SOURCE_DIR</span><span class="o">}</span><span class="s">/lib</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 生成动态库
</span></span></span><span class="line"><span class="cl"><span class="c">#add_library(calc SHARED ${SRC_LIST})
</span></span></span><span class="line"><span class="cl"><span class="c"># 生成静态库
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">add_library</span><span class="p">(</span><span class="s">calc</span> <span class="s">STATIC</span> <span class="o">${</span><span class="nv">SRC_LIST</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 包含库文件
</span></span></span><span class="line"><span class="cl"><span class="c"># 链接静态库的命令如下：参数1：指定出要链接的静态库的名字，可以是全名 libxxx.a，也可以是掐头（lib）去尾（.a）之后的名字 xxx。参数2-N：要链接的其它静态库的名字
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">link_libraries</span><span class="p">(</span><span class="s">&lt;static</span> <span class="s">lib&gt;</span> <span class="s">[&lt;static</span> <span class="s">lib&gt;...]</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">如果该静态库不是系统提供的（自己制作或者使用第三方提供的静态库）可能出现静态库找不到的情况，此时可以将静态库的路径也指定出来：
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">link_directories</span><span class="p">(</span><span class="s">&lt;lib</span> <span class="s">path&gt;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 包含静态库路径
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">link_directories</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_SOURCE_DIR</span><span class="o">}</span><span class="s">/lib</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 链接静态库
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">link_libraries</span><span class="p">(</span><span class="s">calc</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 链接动态库，使用 target_link_libraries 命令就可以链接动态库，也可以链接静态库文件。
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">target_link_libraries</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s">&lt;target&gt;</span> 
</span></span><span class="line"><span class="cl">    <span class="s">&lt;PRIVATE|PUBLIC|INTERFACE&gt;</span> <span class="s">&lt;item&gt;...</span> 
</span></span><span class="line"><span class="cl">    <span class="s">[&lt;PRIVATE|PUBLIC|INTERFACE&gt;</span> <span class="s">&lt;item&gt;...]...</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">target：指定要加载动态库的文件的名字该文件可能是一个源文件,or动态库文件or可执行文件
</span></span></span><span class="line"><span class="cl"><span class="err">PRIVATE|PUBLIC|INTERFACE：动态库的访问权限，默认为PUBLIC
</span></span></span><span class="line"><span class="cl"><span class="err">如果各个动态库之间没有依赖关系，无需做任何设置，三者没有没有区别，一般无需指定，使用默认的</span> <span class="err">PUBLIC</span> <span class="err">即可。
</span></span></span><span class="line"><span class="cl"><span class="err">PUBLIC：在public后面的库会被Link到前面的target中，并且里面的符号也会被导出，提供给第三方使用。
</span></span></span><span class="line"><span class="cl"><span class="err">PRIVATE：在private后面的库仅被link到前面的target中，并且终结掉，第三方不能感知你调了啥库
</span></span></span><span class="line"><span class="cl"><span class="err">INTERFACE：在interface后面引入的库不会被链接到前面的target中，只会导出符号。
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">动态库的链接和静态库是完全不同的：
</span></span></span><span class="line"><span class="cl"><span class="err">静态库会在生成可执行程序的链接阶段被打包到可执行程序中，所以可执行程序启动，静态库就被加载到内存中了。
</span></span></span><span class="line"><span class="cl"><span class="err">动态库在生成可执行程序的链接阶段不会被打包到可执行程序中，当可执行程序被启动并且调用了动态库中的函数的时候，动态库才会被加载到内存
</span></span></span><span class="line"><span class="cl"><span class="err">因此，在cmake中指定要链接的动态库的时候，应该将命令写到生成了可执行文件之后：
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 添加并指定最终生成的可执行程序名
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">add_executable</span><span class="p">(</span><span class="s">app</span> <span class="o">${</span><span class="nv">SRC_LIST</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 指定可执行程序要链接的动态库名字
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">target_link_libraries</span><span class="p">(</span><span class="s">app</span> <span class="s">pthread</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">app:</span> <span class="err">对应的是最终生成的可执行程序的名字
</span></span></span><span class="line"><span class="cl"><span class="err">pthread：这是可执行程序要加载的动态库，这个库是系统提供的线程库，全名为libpthread.so，在指定的时候一般会掐头（lib）去尾（.so）。
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 链接第三方动态库，假设在测试文件main.cpp中既使用了自己制作的动态库libcalc.so又使用了系统提供的线程库，此时CMakeLists.txt文件可以这样写：、
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.0</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">project</span><span class="p">(</span><span class="s">TEST</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">file</span><span class="p">(</span><span class="s">GLOB</span> <span class="s">SRC_LIST</span> <span class="o">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="o">}</span><span class="s">/*.cpp</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">include_directories</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_SOURCE_DIR</span><span class="o">}</span><span class="s">/include</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_executable</span><span class="p">(</span><span class="s">app</span> <span class="o">${</span><span class="nv">SRC_LIST</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">target_link_libraries</span><span class="p">(</span><span class="s">app</span> <span class="s">pthread</span> <span class="s">calc</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">pthread、calc都是可执行程序app要链接的动态库的名字。当可执行程序app生成之后并执行该文件，会提示有如下错误信息：
</span></span></span><span class="line"><span class="cl"><span class="err">error</span> <span class="err">while</span> <span class="err">loading</span> <span class="err">shared</span> <span class="err">libraries:</span> <span class="err">libcalc.so:</span> <span class="err">cannot</span> <span class="err">open</span> <span class="err">shared</span> <span class="err">object</span> <span class="err">file:</span> <span class="err">No</span> <span class="err">such</span> <span class="err">file</span> <span class="err">or</span> <span class="err">directory
</span></span></span><span class="line"><span class="cl"><span class="err">这是因为可执行程序启动之后，去加载calc这个动态库，但是不知道这个动态库被放到了什么位置，所以就加载失败了，在</span> <span class="err">CMake</span> <span class="err">中可以在生成可执行程序之前，通过命令指定出要链接的动态库的位置，指定静态库位置使用的也是这个命令：
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">link_directories</span><span class="p">(</span><span class="s">path</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">修改之后的CMakeLists.txt文件应该是这样的：
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.0</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">project</span><span class="p">(</span><span class="s">TEST</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">file</span><span class="p">(</span><span class="s">GLOB</span> <span class="s">SRC_LIST</span> <span class="o">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="o">}</span><span class="s">/*.cpp</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 指定源文件或者动态库对应的头文件路径
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">include_directories</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_SOURCE_DIR</span><span class="o">}</span><span class="s">/include</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 指定要链接的动态库的路径
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">link_directories</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_SOURCE_DIR</span><span class="o">}</span><span class="s">/lib</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 添加并生成一个可执行程序
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">add_executable</span><span class="p">(</span><span class="s">app</span> <span class="o">${</span><span class="nv">SRC_LIST</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 指定要链接的动态库
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">target_link_libraries</span><span class="p">(</span><span class="s">app</span> <span class="s">pthread</span> <span class="s">calc</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 日志，在CMake中可以用message显示一条消息
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">message</span><span class="p">(</span><span class="s">[STATUS|WARNING|AUTHOR_WARNING|FATAL_ERROR|SEND_ERROR]</span> <span class="s2">&#34;message to display&#34;</span> <span class="s">...</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">(无)</span> <span class="err">：重要消息
</span></span></span><span class="line"><span class="cl"><span class="err">STATUS</span> <span class="err">：非重要消息
</span></span></span><span class="line"><span class="cl"><span class="err">WARNING：CMake</span> <span class="err">警告,</span> <span class="err">会继续执行
</span></span></span><span class="line"><span class="cl"><span class="err">AUTHOR_WARNING：CMake</span> <span class="nb">警告</span> <span class="p">(</span><span class="s">dev</span><span class="p">)</span><span class="err">,</span> <span class="err">会继续执行
</span></span></span><span class="line"><span class="cl"><span class="err">SEND_ERROR：CMake</span> <span class="err">错误,</span> <span class="err">继续执行，但是会跳过生成的步骤
</span></span></span><span class="line"><span class="cl"><span class="err">FATAL_ERROR：CMake</span> <span class="err">错误,</span> <span class="err">终止所有处理过程
</span></span></span><span class="line"><span class="cl"><span class="err">CMake的命令行工具会在stdout上显示STATUS消息，在stderr上显示其他所有消息。CMake的GUI会在它的log区域显示所有消息。
</span></span></span><span class="line"><span class="cl"><span class="err">CMake警告和错误消息的文本显示使用的是一种简单的标记语言。文本没有缩进，超过长度的行会回卷，段落之间以新行做为分隔符。
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 输出一般日志信息
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;source path: ${PROJECT_SOURCE_DIR}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 输出警告信息
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">message</span><span class="p">(</span><span class="s">WARNING</span> <span class="s2">&#34;source path: ${PROJECT_SOURCE_DIR}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 输出错误信息
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">message</span><span class="p">(</span><span class="s">FATAL_ERROR</span> <span class="s2">&#34;source path: ${PROJECT_SOURCE_DIR}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 变量操作
</span></span></span><span class="line"><span class="cl"><span class="c"># 追加 -使用set拼接
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="err">如果使用set进行字符串拼接，对应的命令格式如下：
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">变量名1</span> <span class="o">${</span><span class="nv">变量名1</span><span class="o">}</span> <span class="o">${</span><span class="nv">变量名2</span><span class="o">}</span> <span class="s">...</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">将从第二个参数开始往后所有的字符串进行拼接，最后将结果存储到第一个参数中，如果第一个参数中原来有数据会对原数据就行覆盖。
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># eg
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">set</span><span class="p">(</span><span class="s">TEMP</span> <span class="s2">&#34;hello,world&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">file</span><span class="p">(</span><span class="s">GLOB</span> <span class="s">SRC_1</span> <span class="o">${</span><span class="nv">PROJECT_SOURCE_DIR</span><span class="o">}</span><span class="s">/src1/*.cpp</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">file</span><span class="p">(</span><span class="s">GLOB</span> <span class="s">SRC_2</span> <span class="o">${</span><span class="nv">PROJECT_SOURCE_DIR</span><span class="o">}</span><span class="s">/src2/*.cpp</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 追加(拼接),将src1，src2，temp拼接为一个str存到src1中
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">set</span><span class="p">(</span><span class="s">SRC_1</span> <span class="o">${</span><span class="nv">SRC_1</span><span class="o">}</span> <span class="o">${</span><span class="nv">SRC_2</span><span class="o">}</span> <span class="o">${</span><span class="nv">TEMP</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;message: ${SRC_1}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 使用list拼接
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">list</span><span class="p">(</span><span class="s">APPEND</span> <span class="s">&lt;list&gt;</span> <span class="s">[&lt;element&gt;</span> <span class="s">...]</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">list命令的功能比set要强大，字符串拼接只是它的其中一个功能，所以需要在它第一个参数的位置指定出我们要做的操作，APPEND表示进行数据追加，后边的参数和set就一样了。
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 追加(拼接),APPEND后面同set的参数一致
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">list</span><span class="p">(</span><span class="s">APPEND</span> <span class="s">SRC_1</span> <span class="o">${</span><span class="nv">SRC_1</span><span class="o">}</span> <span class="o">${</span><span class="nv">SRC_2</span><span class="o">}</span> <span class="o">${</span><span class="nv">TEMP</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;message: ${SRC_1}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">使用set命令可以创建一个list。一个在list内部是一个由分号;分割的一组字符串。例如，</span><span class="nb">set</span><span class="p">(</span><span class="s">var</span> <span class="s">a</span> <span class="s">b</span> <span class="s">c</span> <span class="s">d</span> <span class="s">e</span><span class="p">)</span><span class="err">命令将会创建一个list:a;b;c;d;e，但是最终打印变量值的时候得到的是abcde。
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">tmp1</span> <span class="s">a;b;c;d;e</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">tmp2</span> <span class="s">a</span> <span class="s">b</span> <span class="s">c</span> <span class="s">d</span> <span class="s">e</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="o">${</span><span class="nv">tmp1</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="o">${</span><span class="nv">tmp2</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">输出的结果:
</span></span></span><span class="line"><span class="cl"><span class="err">abcde
</span></span></span><span class="line"><span class="cl"><span class="err">abcde
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 字符串移除
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="err">在当前这么目录有五个源文件，其中main.cpp是一个测试文件。如果我们想要把计算器相关的源文件生成一个动态库给别人使用，那么只需要add.cpp、div.cp、mult.cpp、sub.cpp这四个源文件就可以了。此时，就需要将main.cpp从搜索到的数据中剔除出去，想要实现这个功能，也可以使用list
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">list</span><span class="p">(</span><span class="s">REMOVE_ITEM</span> <span class="s">&lt;list&gt;</span> <span class="s">&lt;value&gt;</span> <span class="s">[&lt;value&gt;</span> <span class="s">...]</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">通过上面的命令原型可以看到删除和追加数据类似，只不过是第一个参数变成了REMOVE_ITEM。
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.0</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">project</span><span class="p">(</span><span class="s">TEST</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">TEMP</span> <span class="s2">&#34;hello,world&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">file</span><span class="p">(</span><span class="s">GLOB</span> <span class="s">SRC_1</span> <span class="o">${</span><span class="nv">PROJECT_SOURCE_DIR</span><span class="o">}</span><span class="s">/*.cpp</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 移除前日志
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;message: ${SRC_1}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 移除 main.cpp
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">list</span><span class="p">(</span><span class="s">REMOVE_ITEM</span> <span class="s">SRC_1</span> <span class="o">${</span><span class="nv">PROJECT_SOURCE_DIR</span><span class="o">}</span><span class="s">/main.cpp</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 移除后日志
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;message: ${SRC_1}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">可以看到，在第8行把将要移除的文件的名字指定给list就可以了。但是一定要注意通过</span> <span class="err">file</span> <span class="err">命令搜索源文件的时候得到的是文件的绝对路径（在list中每个文件对应的路径都是一个item，并且都是绝对路径），那么在移除的时候也要将该文件的绝对路径指定出来才可以，否是移除操作不会成功。
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">关于list命令还有其它功能，但是并不常用，在此就不一一进行举例介绍了。
</span></span></span><span class="line"><span class="cl"><span class="err">获取</span> <span class="err">list</span> <span class="err">的长度。
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">list</span><span class="p">(</span><span class="s">LENGTH</span> <span class="s">&lt;list&gt;</span> <span class="s">&lt;output</span> <span class="s">variable&gt;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">LENGTH：子命令LENGTH用于读取列表长度
</span></span></span><span class="line"><span class="cl"><span class="err">&lt;list&gt;：当前操作的列表
</span></span></span><span class="line"><span class="cl"><span class="err">&lt;output</span> <span class="err">variable&gt;：新创建的变量，用于存储列表的长度。
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">读取列表中指定索引的的元素，可以指定多个索引
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">list</span><span class="p">(</span><span class="s">GET</span> <span class="s">&lt;list&gt;</span> <span class="s">&lt;element</span> <span class="s">index&gt;</span> <span class="s">[&lt;element</span> <span class="s">index&gt;</span> <span class="s">...]</span> <span class="s">&lt;output</span> <span class="s">variable&gt;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">&lt;list&gt;：当前操作的列表
</span></span></span><span class="line"><span class="cl"><span class="err">&lt;element</span> <span class="err">index&gt;：列表元素的索引
</span></span></span><span class="line"><span class="cl"><span class="err">从0开始编号，索引0的元素为列表中的第一个元素；
</span></span></span><span class="line"><span class="cl"><span class="err">索引也可以是负数，-1表示列表的最后一个元素，-2表示列表倒数第二个元素，以此类推
</span></span></span><span class="line"><span class="cl"><span class="err">当索引（不管是正还是负）超过列表的长度，运行会报错
</span></span></span><span class="line"><span class="cl"><span class="err">&lt;output</span> <span class="err">variable&gt;：新创建的变量，存储指定索引元素的返回结果，也是一个列表。
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">将列表中的元素用连接符（字符串）连接起来组成一个字符串
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">list</span> <span class="p">(</span><span class="s">JOIN</span> <span class="s">&lt;list&gt;</span> <span class="s">&lt;glue&gt;</span> <span class="s">&lt;output</span> <span class="s">variable&gt;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">&lt;list&gt;：当前操作的列表
</span></span></span><span class="line"><span class="cl"><span class="err">&lt;glue&gt;：指定的连接符（字符串）
</span></span></span><span class="line"><span class="cl"><span class="err">&lt;output</span> <span class="err">variable&gt;：新创建的变量，存储返回的字符串
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">查找列表是否存在指定的元素，若果未找到，返回-1
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">list</span><span class="p">(</span><span class="s">FIND</span> <span class="s">&lt;list&gt;</span> <span class="s">&lt;value&gt;</span> <span class="s">&lt;output</span> <span class="s">variable&gt;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">&lt;list&gt;：当前操作的列表
</span></span></span><span class="line"><span class="cl"><span class="err">&lt;value&gt;：需要再列表中搜索的元素
</span></span></span><span class="line"><span class="cl"><span class="err">&lt;output</span> <span class="err">variable&gt;：新创建的变量
</span></span></span><span class="line"><span class="cl"><span class="err">如果列表&lt;list&gt;中存在&lt;value&gt;，那么返回&lt;value&gt;在列表中的索引
</span></span></span><span class="line"><span class="cl"><span class="err">如果未找到则返回-1。
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">将元素追加到列表中
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">list</span> <span class="p">(</span><span class="s">APPEND</span> <span class="s">&lt;list&gt;</span> <span class="s">[&lt;element&gt;</span> <span class="s">...]</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">在list中指定的位置插入若干元素
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">list</span><span class="p">(</span><span class="s">INSERT</span> <span class="s">&lt;list&gt;</span> <span class="s">&lt;element_index&gt;</span> <span class="s">&lt;element&gt;</span> <span class="s">[&lt;element&gt;</span> <span class="s">...]</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">将元素插入到列表的0索引位置
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">list</span> <span class="p">(</span><span class="s">PREPEND</span> <span class="s">&lt;list&gt;</span> <span class="s">[&lt;element&gt;</span> <span class="s">...]</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">将列表中最后元素移除
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">list</span> <span class="p">(</span><span class="s">POP_BACK</span> <span class="s">&lt;list&gt;</span> <span class="s">[&lt;out-var&gt;...]</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">将列表中第一个元素移除
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">list</span> <span class="p">(</span><span class="s">POP_FRONT</span> <span class="s">&lt;list&gt;</span> <span class="s">[&lt;out-var&gt;...]</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">将指定的元素从列表中移除
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">list</span> <span class="p">(</span><span class="s">REMOVE_ITEM</span> <span class="s">&lt;list&gt;</span> <span class="s">&lt;value&gt;</span> <span class="s">[&lt;value&gt;</span> <span class="s">...]</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">将指定索引的元素从列表中移除
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">list</span> <span class="p">(</span><span class="s">REMOVE_AT</span> <span class="s">&lt;list&gt;</span> <span class="s">&lt;index&gt;</span> <span class="s">[&lt;index&gt;</span> <span class="s">...]</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">移除列表中的重复元素
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">list</span> <span class="p">(</span><span class="s">REMOVE_DUPLICATES</span> <span class="s">&lt;list&gt;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">列表翻转
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">list</span><span class="p">(</span><span class="s">REVERSE</span> <span class="s">&lt;list&gt;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">列表排序
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">list</span> <span class="p">(</span><span class="s">SORT</span> <span class="s">&lt;list&gt;</span> <span class="s">[COMPARE</span> <span class="s">&lt;compare&gt;]</span> <span class="s">[CASE</span> <span class="s">&lt;case&gt;]</span> <span class="s">[ORDER</span> <span class="s">&lt;order&gt;]</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">COMPARE：指定排序方法。有如下几种值可选：
</span></span></span><span class="line"><span class="cl"><span class="err">STRING:按照字母顺序进行排序，为默认的排序方法
</span></span></span><span class="line"><span class="cl"><span class="err">FILE_BASENAME：如果是一系列路径名，会使用basename进行排序
</span></span></span><span class="line"><span class="cl"><span class="err">NATURAL：使用自然数顺序排序
</span></span></span><span class="line"><span class="cl"><span class="err">CASE：指明是否大小写敏感。有如下几种值可选：
</span></span></span><span class="line"><span class="cl"><span class="err">SENSITIVE:</span> <span class="err">按照大小写敏感的方式进行排序，为默认值
</span></span></span><span class="line"><span class="cl"><span class="err">INSENSITIVE：按照大小写不敏感方式进行排序
</span></span></span><span class="line"><span class="cl"><span class="err">ORDER：指明排序的顺序。有如下几种值可选：
</span></span></span><span class="line"><span class="cl"><span class="err">ASCENDING:按照升序排列，为默认值
</span></span></span><span class="line"><span class="cl"><span class="err">DESCENDING：按照降序排列
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 宏定义
</span></span></span><span class="line"><span class="cl"><span class="c">#ifdef DEBUG
</span></span></span><span class="line"><span class="cl"><span class="c"></span>    <span class="nb">printf</span><span class="p">(</span><span class="s2">&#34;我是一个程序猿, 我不会爬树...\n&#34;</span><span class="p">)</span><span class="err">;
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c">#endif
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="err">为了让测试更灵活，我们可以不在代码中定义所需定义的宏，而是在测试的时候去把它定义出来，其中一种方式就是在gcc/g++命令中去指定
</span></span></span><span class="line"><span class="cl"><span class="err">$</span> <span class="err">gcc</span> <span class="err">test.c</span> <span class="err">-DDEBUG</span> <span class="err">-o</span> <span class="err">app
</span></span></span><span class="line"><span class="cl"><span class="err">在gcc/g++命令中通过参数</span> <span class="err">-D指定出要定义的宏的名字，这样就相当于在代码中定义了一个宏，其名字为DEBUG。
</span></span></span><span class="line"><span class="cl"><span class="err">在CMake中我们也可以做类似的事情，对应的命令叫做add_definitions:
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_definitions</span><span class="p">(</span><span class="s">-D宏名称</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 自定义 DEBUG 宏
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">add_definitions</span><span class="p">(</span><span class="s">-DDEBUG</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_executable</span><span class="p">(</span><span class="s">app</span> <span class="s">./test.c</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># cmake预定义宏
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="err">宏</span>	<span class="err">功能
</span></span></span><span class="line"><span class="cl"><span class="err">PROJECT_SOURCE_DIR</span>			<span class="err">使用cmake命令后紧跟的目录，一般是工程的根目录
</span></span></span><span class="line"><span class="cl"><span class="err">PROJECT_BINARY_DIR</span>			<span class="err">执行cmake命令的目录
</span></span></span><span class="line"><span class="cl"><span class="err">CMAKE_CURRENT_SOURCE_DIR</span>	<span class="err">当前处理的CMakeLists.txt所在的路径
</span></span></span><span class="line"><span class="cl"><span class="err">CMAKE_CURRENT_BINARY_DIR</span>	<span class="err">target</span> <span class="err">编译目录
</span></span></span><span class="line"><span class="cl"><span class="err">EXECUTABLE_OUTPUT_PATH</span>		<span class="err">重新定义目标二进制可执行文件的存放位置
</span></span></span><span class="line"><span class="cl"><span class="err">LIBRARY_OUTPUT_PATH</span>			<span class="err">重新定义目标链接库文件的存放位置
</span></span></span><span class="line"><span class="cl"><span class="err">PROJECT_NAME</span>				<span class="err">返回通过PROJECT指令定义的项目名称
</span></span></span><span class="line"><span class="cl"><span class="err">CMAKE_BINARY_DIR</span>			<span class="err">项目实际构建路径，假设在build目录进行的构建，那么得到的就是这个目录的路径
</span></span></span></code></pre></div><h3 id="执行cmake">执行cmake<a hidden class="anchor" aria-hidden="true" href="#执行cmake">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># 在CMakeLists.txt所在目录执行</span>
</span></span><span class="line"><span class="cl">$ cmake .
</span></span><span class="line"><span class="cl"><span class="c1"># 在build目录执行</span>
</span></span><span class="line"><span class="cl">$ cmake ..
</span></span></code></pre></div><h3 id="cmake-311-fetchcontent模块">CMake 3.11 FetchContent模块<a hidden class="anchor" aria-hidden="true" href="#cmake-311-fetchcontent模块">#</a></h3>
<p><code>FetchContent</code> 是 CMake 3.11 及以上版本中引入的一个功能，它允许你在构建时自动从外部获取依赖项，而不需要手动下载或预先安装它们。</p>
<h4 id="编写cmake">编写cmake：<a hidden class="anchor" aria-hidden="true" href="#编写cmake">#</a></h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cmake" data-lang="cmake"><span class="line"><span class="cl"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.14</span><span class="p">)</span> <span class="c"># 确保使用了足够新的 CMake 版本
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">project</span><span class="p">(</span><span class="s">MyProject</span> <span class="s">VERSION</span> <span class="s">1.0</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 包含 FetchContent 模块
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">include</span><span class="p">(</span><span class="s">FetchContent</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 声明 GoogleTest 作为外部依赖项
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">FetchContent_Declare</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="s">googletest</span>
</span></span><span class="line"><span class="cl">  <span class="s">GIT_REPOSITORY</span> <span class="s">https://github.com/google/googletest.git</span>
</span></span><span class="line"><span class="cl">  <span class="s">GIT_TAG</span>        <span class="s">release-1.10.0</span> <span class="c"># GIT_TAG 参数可以是分支名或标签，不是必须的，但它是推荐的做法，不指定下载默认分支
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 使外部依赖项（GoogleTest）可用
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">FetchContent_MakeAvailable</span><span class="p">(</span><span class="s">googletest</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 添加你的项目文件（替换为你的源文件）
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">add_executable</span><span class="p">(</span><span class="s">my_project</span> <span class="s">main.cpp</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 定义一个测试目标
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">enable_testing</span><span class="p">()</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 添加测试可执行文件
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">add_executable</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="s">my_test</span>
</span></span><span class="line"><span class="cl">  <span class="s">tests/test1.cpp</span>
</span></span><span class="line"><span class="cl">  <span class="s">tests/test2.cpp</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 链接 GoogleTest 到测试可执行文件
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">target_link_libraries</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="s">my_test</span>
</span></span><span class="line"><span class="cl">  <span class="s">gtest_main</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 包含 GoogleTest 的测试
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">include</span><span class="p">(</span><span class="s">GoogleTest</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">gtest_discover_tests</span><span class="p">(</span><span class="s">my_test</span><span class="p">)</span><span class="err">
</span></span></span></code></pre></div><p>在这个示例中：</p>
<ul>
<li>使用 <code>FetchContent_Declare</code> 声明了 GoogleTest 作为一个外部依赖项，指定了其 Git 仓库地址和要使用的标签（在这个例子中是 <code>release-1.10.0</code>）。</li>
<li>通过 <code>FetchContent_MakeAvailable</code> 自动下载（如果需要的话）、配置和构建 GoogleTest。</li>
<li>创建了两个可执行文件目标：一个是主项目 <code>my_project</code>，另一个是测试项目 <code>my_test</code>。</li>
<li><code>my_test</code> 测试可执行文件链接了 GoogleTest，并使用 <code>gtest_discover_tests</code> 自动发现和注册 GoogleTest 测试。</li>
</ul>
<h4 id="第二步编写测试">第二步：编写测试<a hidden class="anchor" aria-hidden="true" href="#第二步编写测试">#</a></h4>
<p>在 <code>tests</code> 目录下创建测试文件（例如，<code>test1.cpp</code> 和 <code>test2.cpp</code>），并使用 GoogleTest 编写测试。</p>
<h4 id="第三步构建和运行测试">第三步：构建和运行测试<a hidden class="anchor" aria-hidden="true" href="#第三步构建和运行测试">#</a></h4>
<ol>
<li>
<p>创建一个构建目录并进入：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">mkdir build <span class="o">&amp;&amp;</span> <span class="nb">cd</span> build
</span></span></code></pre></div></li>
<li>
<p>使用 CMake 配置项目并构建：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">cmake --build .
</span></span></code></pre></div></li>
<li>
<p>运行测试：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">ctest
</span></span></code></pre></div></li>
</ol>
<h4 id="使用catch2-v3x版本的测试cmake">使用catch2 v3.x版本的测试cmake<a hidden class="anchor" aria-hidden="true" href="#使用catch2-v3x版本的测试cmake">#</a></h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cmake" data-lang="cmake"><span class="line"><span class="cl"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.14</span><span class="p">)</span> <span class="c"># 确保使用的是 FetchContent 可用的 CMake 版本
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">project</span><span class="p">(</span><span class="s">MyProject</span> <span class="s">VERSION</span> <span class="s">1.0</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">include_directories</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_SOURCE_DIR</span><span class="o">}</span><span class="s">/include</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 包含 FetchContent 模块
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">include</span><span class="p">(</span><span class="s">FetchContent</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 使用 FetchContent_Declare 声明 Catch2 作为外部依赖项
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">FetchContent_Declare</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="s">Catch2</span>
</span></span><span class="line"><span class="cl">        <span class="s">GIT_REPOSITORY</span> <span class="s">https://github.com/catchorg/Catch2.git</span>
</span></span><span class="line"><span class="cl">        <span class="s">GIT_TAG</span>        <span class="s">v3.3.0</span> <span class="c"># or a later release
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 使 Catch2 可用
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">FetchContent_MakeAvailable</span><span class="p">(</span><span class="s">Catch2</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 添加你的项目文件（示例）
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">add_executable</span><span class="p">(</span><span class="s">my_project</span> <span class="s">src/main.cpp</span> <span class="s">src/sub.cpp</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 如果你有测试代码，可以像这样设置
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">enable_testing</span><span class="p">()</span> <span class="c"># 启用测试
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 添加测试可执行文件
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">add_executable</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="s">my_test</span>
</span></span><span class="line"><span class="cl">  <span class="s">test/test1.cpp</span>
</span></span><span class="line"><span class="cl">  <span class="s">src/sub.cpp</span>
</span></span><span class="line"><span class="cl">  <span class="c"># 添加其他测试文件
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 链接 Catch2 到测试可执行文件
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">target_link_libraries</span><span class="p">(</span><span class="s">my_test</span> <span class="s">PRIVATE</span> <span class="s">Catch2::Catch2WithMain</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 为 Catch2 配置测试发现
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">LIST</span><span class="p">(</span><span class="s">APPEND</span> <span class="s">CMAKE_MODULE_PATH</span> <span class="o">${</span><span class="nv">catch2_SOURCE_DIR</span><span class="o">}</span><span class="s">/extras</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">include</span><span class="p">(</span><span class="s">CTest</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">include</span><span class="p">(</span><span class="s">Catch</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">CATCH_DISCOVER_TESTS</span><span class="p">(</span><span class="s">my_test</span><span class="p">)</span><span class="err">
</span></span></span></code></pre></div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/cmake/">Cmake</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/catch2/">
    <span class="title">« Prev</span>
    <br>
    <span>catch2测试框架</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/protocol-buffer/">
    <span class="title">Next »</span>
    <br>
    <span>Protocol Buffer的使用</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="http://localhost:1313/">Cookie&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
